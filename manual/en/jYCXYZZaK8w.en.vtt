WEBVTT
Kind: captions
Language: en

00:00:01.834 --> 00:00:07.434
Welcome. In this series of videos, you'll learn how to use ICE to copy and merge topologies.

00:00:08.300 --> 00:00:10.863
You'll also learn how to apply materials using ICE.

00:00:11.911 --> 00:00:14.722
The goal is to generate a building from predefined parts.

00:00:15.316 --> 00:00:19.941
In this example, you will use a main floor, a middle floor, and a roof as templates.

00:00:21.788 --> 00:00:24.683
There are several advantages to using ICE modeling for this.

00:00:25.756 --> 00:00:29.362
For one thing, you can create a slider to change the number of floors interactively.

00:00:30.284 --> 00:00:33.816
This would not be possible with a non-ICE approach such as cloning and merging.

00:00:34.393 --> 00:00:37.815
Cloning and merging would also create many extra objects in the scene.

00:00:38.739 --> 00:00:41.660
Another approach might be to duplicate polygon islands.

00:00:42.456 --> 00:00:46.269
This doesn't require as many extra objects, and also provides a slider.

00:00:46.955 --> 00:00:51.004
However, it would be difficult to update the roof's position when you change the number of floors.

00:00:51.643 --> 00:00:55.816
It would also be difficult to move all the upper parts when you modify something below them.

00:00:56.602 --> 00:01:02.808
ICE modeling offers good solutions for most of these problems so it's an ideal approach to a project like this.

00:01:03.885 --> 00:01:07.763
Before re-creating the building from scratch, let's explore this scene further.

00:01:08.938 --> 00:01:11.593
The 3 templates were modeled to fit together perfectly.

00:01:12.372 --> 00:01:14.221
And they've been offset to see them better.

00:01:14.921 --> 00:01:18.980
In addition, there is a null which is used to control the placement of the building.

00:01:26.258 --> 00:01:32.930
There's also an empty mesh called Material_Container that acts as a convenient central location to manage all the materials.

00:01:34.305 --> 00:01:43.884
This material container has an ICE tree that gets the names of materials, puts them in an array, and stores the array as a special ICE attribute named Materials.

00:01:45.096 --> 00:01:53.508
An array is an ordered list of elements. When referring to elements in the list you must use the array indices such as 0, 1, 2, and so on.

00:01:57.120 --> 00:02:02.291
Each of the 3 meshes has an ICE tree that copies the Materials attribute from the material container.

00:02:03.258 --> 00:02:09.042
This allows you to change the Materials defined in the container, and all objects will update automatically.

00:02:09.587 --> 00:02:14.370
The tree also sets each polygon's MaterialID based on pre-existing clusters.

00:02:15.775 --> 00:02:22.134
MaterialID is a special ICE attribute that specifies which material in the Materials array to apply per polygon.

00:02:24.088 --> 00:02:26.948
For each material, the tree gets each cluster by name,

00:02:27.555 --> 00:02:32.498
and sets the polygons' Material ID to the corresponding index of the Materials array.

00:02:33.853 --> 00:02:41.653
Note that for the Material ID attribute, the  integer 1 refers to the first material in the array even though its array index is 0.

00:02:42.603 --> 00:02:47.977
This is because the Material ID 0 always refers to the material applied directly to the object.

00:02:51.508 --> 00:02:55.227
The building has an ICE tree that builds its topology based on the templates,

00:02:56.134 --> 00:02:59.120
then transfers the MaterialID attributes from the templates,

00:02:59.653 --> 00:03:02.525
and finally copies the Materials array from the container.

00:03:03.836 --> 00:03:07.930
Before rebuilding this tree from scratch, let's take a closer look at what it's doing.

00:03:09.086 --> 00:03:11.320
This will make it easier to follow along later.

00:03:12.477 --> 00:03:15.964
The top branch gets the main floor, middle floor, and roof.

00:03:16.714 --> 00:03:18.964
Then it gets their Topology attributes,

00:03:21.548 --> 00:03:24.477
transforms the topologies,

00:03:25.041 --> 00:03:27.414
builds an array from the transformed topologies,

00:03:28.257 --> 00:03:29.853
and finally sets the building's topology.

00:03:30.850 --> 00:03:33.670
If we take a closer look at the Set Topologies compound,

00:03:34.131 --> 00:03:38.662
it just merges the topology array and sets the Topology attribute on the Self object.

00:03:44.598 --> 00:03:50.865
For the middle floors, there's a second array that gets inserted into the middle of the main array, between the main floor and the roof.

00:03:52.412 --> 00:03:56.912
The transform that gets applied to the topologies is based on the null's global kinematics.

00:03:57.808 --> 00:04:01.786
There are also some additional offsets that need to be applied for the middle floors and roof.

00:04:03.677 --> 00:04:06.993
The second branch of the tree sets the material IDs of the polygons.

00:04:08.193 --> 00:04:12.848
The polygon index is used to determine the corresponding polygon on the original object.

00:04:13.570 --> 00:04:18.226
Then the tree looks up the Material ID of the original polygon and sets it on the new one.

00:04:19.243 --> 00:04:23.786
Different operations are needed to calculate the corresponding polygon on the original objects,

00:04:24.226 --> 00:04:28.708
depending on whether the polygon is on the main floor, middle floors, or roof.

00:04:29.756 --> 00:04:32.102
The last branch of the tree is very simple.

00:04:32.800 --> 00:04:38.400
It just gets and sets the Materials array from the materials container, just like on every other object.

00:04:39.842 --> 00:04:42.452
So now we've got a good overview of how the tree works.

00:04:43.095 --> 00:04:46.514
In the next video, we'll see how it was put together in the first place.

