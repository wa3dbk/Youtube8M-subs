WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:03.150
So now let's go back to
this figure again over here.

00:00:03.150 --> 00:00:08.070
So if you look at my processor,
I have my core over here

00:00:08.070 --> 00:00:12.480
that I have an L1 cache, I have
a larger L2 cache, and so on.

00:00:12.480 --> 00:00:14.970
So let's say that I have a
miss in all of these caches,

00:00:14.970 --> 00:00:18.720
and I ultimately need to get
my data from physical memory.

00:00:18.720 --> 00:00:22.510
So now, having the virtual
error-- so the core

00:00:22.510 --> 00:00:25.980
issues a request saying
load something in.

00:00:25.980 --> 00:00:28.660
And it's always going to
refer to the virtual address,

00:00:28.660 --> 00:00:30.730
because the application
and the binary

00:00:30.730 --> 00:00:32.420
always deal with just
virtual addresses

00:00:32.420 --> 00:00:34.334
because that is all
that is visible to them.

00:00:34.334 --> 00:00:36.500
We're giving them the
illusion that they have access

00:00:36.500 --> 00:00:39.280
to this contiguous eight
gigabytes of space.

00:00:39.280 --> 00:00:42.930
The application has no idea that
these virtual addresses that

00:00:42.930 --> 00:00:46.490
are being issued ultimately
translate into virtual page

00:00:46.490 --> 00:00:49.890
numbers which get mapped to some
arbitrary physical page number.

00:00:49.890 --> 00:00:52.330
This is obviously not
known at compile time.

00:00:52.330 --> 00:00:54.720
So the application is issuing
these virtual addresses.

00:00:54.720 --> 00:00:56.620
At run time these
virtual pages are

00:00:56.620 --> 00:01:00.070
being mapped to some
arbitrary physical page.

00:01:00.070 --> 00:01:03.840
So if I do need to get the data
from the physical main memory,

00:01:03.840 --> 00:01:07.860
I have to translate this virtual
address to a physical address.

00:01:07.860 --> 00:01:11.110
And that translation is being
done through the page table

00:01:11.110 --> 00:01:13.860
that I mentioned.

00:01:13.860 --> 00:01:17.050
And these page tables themselves
are fairly large structures.

00:01:17.050 --> 00:01:19.300
It has a million
entries, and there

00:01:19.300 --> 00:01:21.310
could be, say, 20
programs running together.

00:01:21.310 --> 00:01:23.710
So you have 20 million entries.

00:01:23.710 --> 00:01:27.070
Each entry needs a
few bytes of data.

00:01:27.070 --> 00:01:29.490
And so we are talking about
capacities that cannot fit

00:01:29.490 --> 00:01:32.420
in the L2 cache,
or in the L3 cache.

00:01:32.420 --> 00:01:34.050
So these page tables
are large enough

00:01:34.050 --> 00:01:36.790
that they have to be
stored in memory somewhere.

00:01:36.790 --> 00:01:38.990
So let's say that there
is a region of memory that

00:01:38.990 --> 00:01:41.850
is being used and managed
by the operating system

00:01:41.850 --> 00:01:45.550
to store all the
page table entries.

00:01:45.550 --> 00:01:48.120
So in order to translate
the virtual address

00:01:48.120 --> 00:01:52.840
to a physical address, I first
need to read the page table.

00:01:52.840 --> 00:01:55.970
Once I have the page table I
know that virtual address ABC

00:01:55.970 --> 00:01:59.870
is being translated to
a physical address PQR.

00:01:59.870 --> 00:02:03.810
Now I can actually issue my
request to physical page PQR,

00:02:03.810 --> 00:02:05.040
get the data.

00:02:05.040 --> 00:02:08.070
And now the application finally
has the data that it needs.

00:02:08.070 --> 00:02:11.610
So just to get one block
of data from memory,

00:02:11.610 --> 00:02:14.330
I actually need to issue two
different reads to memory.

00:02:14.330 --> 00:02:16.650
One to get the page
table translation,

00:02:16.650 --> 00:02:19.040
and one to get the data itself.

00:02:19.040 --> 00:02:22.400
So this is clearly
very, very expensive.

00:02:22.400 --> 00:02:25.220
So to avoid this high
cost, what is done

00:02:25.220 --> 00:02:27.940
is that a portion
of the page table

00:02:27.940 --> 00:02:31.662
is stored on the processor in
a structure called the TLB.

00:02:31.662 --> 00:02:33.620
So let me just blow up
the structure over here.

00:02:33.620 --> 00:02:37.750
So this is called the TLB,
which is a translation lookaside

00:02:37.750 --> 00:02:41.980
buffer, which is a fairly
complicated name for something

00:02:41.980 --> 00:02:46.380
that can also be called
a page table cache.

00:02:46.380 --> 00:02:50.790
So since the page table
has a million entries

00:02:50.790 --> 00:02:52.650
it is hard to keep
all of it on-chip.

00:02:52.650 --> 00:02:56.280
So only a small portion is being
kept in this TLB structure.

00:02:56.280 --> 00:03:01.870
So the TLB could be, let's
say, as little as 64 entries.

00:03:01.870 --> 00:03:03.900
And one entry over
here, for example,

00:03:03.900 --> 00:03:09.070
says that, for process ID7,
virtual page number ABC

00:03:09.070 --> 00:03:13.110
maps to physical
page number PQR.

00:03:13.110 --> 00:03:17.210
So if this is a page, ABC,
that has been touched recently,

00:03:17.210 --> 00:03:22.350
then that translation is being
cached in this TLB structure.

00:03:22.350 --> 00:03:24.991
And so, instead of having to go
to memory to look up the page

00:03:24.991 --> 00:03:26.990
table, you can just look
up the small structure,

00:03:26.990 --> 00:03:29.710
which perhaps takes a
single cycle to access.

00:03:29.710 --> 00:03:31.490
And you can say, well,
virtual page number

00:03:31.490 --> 00:03:34.600
ABC translates to
physical page number PQR.

00:03:34.600 --> 00:03:37.770
Right there I have the physical
address that I'm dealing with.

00:03:37.770 --> 00:03:41.730
So with a single memory
access I can now get my data.

00:03:41.730 --> 00:03:47.290
Just TLB has a certain coverage
that has-- if it has 64 entries

00:03:47.290 --> 00:03:51.460
and each entry can deal with an
eight kilobyte page at a time,

00:03:51.460 --> 00:03:53.850
you're essentially keeping
track of translations

00:03:53.850 --> 00:03:57.910
for 512 kilobytes
worth of memory space.

00:03:57.910 --> 00:04:01.490
So you can handle a working
set size of 512 kilobytes

00:04:01.490 --> 00:04:03.410
without ever having
a miss in the TLB.

00:04:03.410 --> 00:04:05.620
If you have a miss in
the TLB, then again,

00:04:05.620 --> 00:04:10.020
you do have to access memory to
get the page table translation.

00:04:10.020 --> 00:04:12.230
But if you're just
dealing with this--

00:04:12.230 --> 00:04:15.160
let's say 512 kilobytes
worth of data,

00:04:15.160 --> 00:04:19.440
the hope is that you will
always have a TLB hit,

00:04:19.440 --> 00:04:21.589
and you won't have
to do multiple memory

00:04:21.589 --> 00:04:26.656
accesses to get
your data elements.

00:04:26.656 --> 00:04:28.530
So if you want to increase
your TLB coverage,

00:04:28.530 --> 00:04:30.880
one option is to
increase the page size.

00:04:30.880 --> 00:04:32.770
If you went from an
eight kilobyte page size

00:04:32.770 --> 00:04:35.420
to a 16 kilobyte
page size, then you

00:04:35.420 --> 00:04:39.360
TLB coverage would also grow
to one megabyte in size.

00:04:39.360 --> 00:04:41.030
But then the larger
the page size,

00:04:41.030 --> 00:04:44.540
the more memory space
that also gets wasted.

00:04:44.540 --> 00:04:46.890
So the operating system has
to take these into account

00:04:46.890 --> 00:04:48.890
when it defines the page size.

00:04:48.890 --> 00:04:51.630
And later will we also
talk about a concept

00:04:51.630 --> 00:04:54.770
of super pages, which allows
you to dynamically create

00:04:54.770 --> 00:04:56.480
larger page sizes.

00:04:56.480 --> 00:05:00.850
So let me just do a quick
recap before I end this video.

00:05:00.850 --> 00:05:06.020
So, as I said, your application
is producing virtual addresses.

00:05:06.020 --> 00:05:09.270
And not-- each
application need not

00:05:09.270 --> 00:05:13.100
use its entire eight gigabytes
worth of virtual space.

00:05:13.100 --> 00:05:15.749
You're usually using a
smaller fraction of that.

00:05:15.749 --> 00:05:17.790
So if every application
that is currently running

00:05:17.790 --> 00:05:19.960
is using a small fraction
of its entire eight

00:05:19.960 --> 00:05:22.290
gigabytes of virtual
memory space,

00:05:22.290 --> 00:05:26.160
it's possible that all of that
memory fits in physical memory.

00:05:26.160 --> 00:05:30.620
So you may not use
your swap space on disk

00:05:30.620 --> 00:05:32.640
if your memory requirement
is fairly small.

00:05:32.640 --> 00:05:35.057
As the memory
requirement grows, you

00:05:35.057 --> 00:05:37.140
will end up needing more
pages, and you may end up

00:05:37.140 --> 00:05:40.730
spilling some pages
into the swap space.

00:05:40.730 --> 00:05:43.690
So every virtual
address gets translated

00:05:43.690 --> 00:05:45.580
into a physical address.

00:05:45.580 --> 00:05:49.090
And that translation is kept
track of in the page table,

00:05:49.090 --> 00:05:55.370
and some page table entries
are being kept in the TLB.

00:05:55.370 --> 00:05:57.670
We are managing the
physical memory space

00:05:57.670 --> 00:05:59.910
as a fully associative
cache, so your page

00:05:59.910 --> 00:06:02.170
could be placed anywhere
in physical memory,

00:06:02.170 --> 00:06:06.110
and the replacement policy is
usually least recently used.

00:06:06.110 --> 00:06:11.070
And the memory disk hierarchy
is usually exclusive,

00:06:11.070 --> 00:06:13.120
and the write policy
is almost always

00:06:13.120 --> 00:06:18.200
writeback because of the high
cost of doing any disk access.

00:06:18.200 --> 00:06:21.740
As I said, the TLB is a small
fraction of your page table

00:06:21.740 --> 00:06:26.370
entries, and it prevents having
to do two expensive memory

00:06:26.370 --> 00:06:28.530
lookups to get one word of data.

00:06:28.530 --> 00:06:30.370
And by using the
large page size you

00:06:30.370 --> 00:06:34.440
can also increase the
coverage of the TLB.

00:06:34.440 --> 00:06:37.520
So in the next video I'll show
you how the TLB and the cache--

00:06:37.520 --> 00:06:41.400
how those two structures
interact with each other.

