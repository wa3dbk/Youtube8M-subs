WEBVTT
Kind: captions
Language: en

00:00:00.570 --> 00:00:06.900
In this lesson, we will solve a very simple
problem. Given a number n which is a natural

00:00:06.900 --> 00:00:16.660
number, we want to find out all its factors.
For example, if n is lets say 12, then its

00:00:16.660 --> 00:00:29.279
factors are 1 and 1 divides all natural numbers.
2, 3, 4 , 6 and 12. So, 12 has 6 factors in

00:00:29.279 --> 00:00:38.020
all. These 6 numbers divide 12. Ok, so if
we have n = 17, we will have only two factors

00:00:38.020 --> 00:00:46.190
- 1 and 17. That's because 17 is a prime number.
If n is 36, then the factors would be 1,2,

00:00:46.190 --> 00:00:58.700
3, 4, 6, 9 , 12 , 18 and 36. So, there are
9 factors of 36. So, how do we solve this

00:00:58.700 --> 00:01:05.880
problem programatically. The simplest approach
is trial division. What we can do is we can

00:01:05.880 --> 00:01:13.159
try dividing n by all numbers starting 1 to
n and find out all the factors. So, algorithm

00:01:13.159 --> 00:01:21.860
would go like lets say we start with an empty
list named A and then we run a loop starting

00:01:21.860 --> 00:01:32.299
1 all the way till n. So, for i starting 1
to n, if i divides n or in other words n modulo

00:01:32.299 --> 00:01:40.920
i is 0, then we add i to list A. So, once
we exit this loop, the list A has all the

00:01:40.920 --> 00:01:48.290
factors of n. Now, there is a simple observation
here. A number is always divided by 1 and

00:01:48.290 --> 00:01:55.840
itself. Apart from 1 and itself, the smallest
factor that it can have is 2 and the largest

00:01:55.840 --> 00:02:03.369
factor that it can have will be n/2. There
would be no factor of n other than n itself

00:02:03.369 --> 00:02:10.380
after n/2. So, we can improve this algorithm
a little here. What we can do is lets say

00:02:10.380 --> 00:02:17.860
instead of starting with an empty list we
start with 1 and n already in the list and

00:02:17.860 --> 00:02:25.810
then we can run our loop through 2 to n/2.
We do not run the loop all the way till n.

00:02:25.810 --> 00:02:32.050
This is definitely better than running loop
till n. Now, what will be the running time

00:02:32.050 --> 00:02:38.990
of this algorithm. We have a loop running
till n/2. So, the time taken is proportional

00:02:38.990 --> 00:02:46.400
to n which in other words, we also say that
this is big-oh of n in terms of time complexity.

00:02:46.400 --> 00:02:52.020
Can we do something better than this. Well,,
lets see. As we know and as we had discussed

00:02:52.020 --> 00:02:57.870
in our previous lessons on primality testing
also, if there is a number a that divides

00:02:57.870 --> 00:03:06.090
number n, then there is another number b equal
n/a that also divides n. The factors of a

00:03:06.090 --> 00:03:11.370
number always exist in pair and we call them
co-factors. We always have a relationship

00:03:11.370 --> 00:03:20.850
like a*b = n. For example, if we pick up the
case of 36 here, then if a =1, then b = 36/1

00:03:20.850 --> 00:03:31.850
which is 36. if a is 2, b would be 18. if
a is 3, b would be 12. if a is 4, b would

00:03:31.850 --> 00:03:40.290
be 9. And if a is 6, then b is also equal
to 6. This happens only when a is square root

00:03:40.290 --> 00:03:46.240
of n, so in this case 6 is square root of
36. So, in the case when a is not equal to

00:03:46.240 --> 00:03:54.040
b, and lets say if a is the smaller one in
the pair, if a &lt; b, then a is less than square

00:03:54.040 --> 00:04:00.120
root of n and b is always greater than square
root of n. And if a is equal to b like in

00:04:00.120 --> 00:04:07.090
the case of 6 here, then they are both equal
to square root of n. We can use this property

00:04:07.090 --> 00:04:12.980
to improve our algorithm. So, what we can
do now is we can again start with an empty

00:04:12.980 --> 00:04:23.010
list and we can run the loop from 1 to square
root of n, so we say for i starting 1 to square

00:04:23.010 --> 00:04:34.260
root of n, if i divides n , or if n modulo
i is 0, then we add i to list a and we also

00:04:34.260 --> 00:04:43.230
add n upon i to list A. So, this will be our
a and this will be our b. Ok, we could have

00:04:43.230 --> 00:04:50.960
chosen to start with 1 and n in the list initially
only, then we would be running the loop starting

00:04:50.960 --> 00:04:57.630
2, but if we are running the loop starting
1, then 1 and n will also come into the list

00:04:57.630 --> 00:05:04.130
in the loop itself. Now, there still is one
issue with this code. We have not handled

00:05:04.130 --> 00:05:11.681
the case when a =b, so when a is equal to
b, using this algorithm we will add the factor

00:05:11.681 --> 00:05:19.410
twice in the list. So, we need to only a little
change to handle this. We need to say that

00:05:19.410 --> 00:05:26.260
if i is not equal to square root of n, which
will be the case when a will be equal to b,

00:05:26.260 --> 00:05:36.351
then only add n/i to list A. As we know when,
the co-factors are equal, then the factor

00:05:36.351 --> 00:05:42.260
is square root of n. Now, a couple of things
here. I have only written a pseudo-code. In

00:05:42.260 --> 00:05:48.000
an actual program, A can be an array or A
can be any other dynamic list available in

00:05:48.000 --> 00:05:53.810
your language like vector in C++. When we
are adding the elements, we are not adding

00:05:53.810 --> 00:05:59.770
them in a sorted order. So, the factors in
the list will not appear in an increasing

00:05:59.770 --> 00:06:05.830
order. If we want a sorted list, then we need
to do some modifications to the algorithm

00:06:05.830 --> 00:06:11.080
to add the factors in a sorted manner. I leave
that as an exercise for you. Ok, so what will

00:06:11.080 --> 00:06:16.600
be the running time or the time complexity
of this algorithm. We have a loop running

00:06:16.600 --> 00:06:21.930
1 to square root of n. So, clearly the time
taken here is proportional to square root

00:06:21.930 --> 00:06:26.520
of n. We have just one loop running till square
root of n. Or in other words, this is big-oh

00:06:26.520 --> 00:06:35.220
of square root of n in terms of big oh notation.
The time complexity is O(sqrt(n)). big-oh

00:06:35.220 --> 00:06:42.450
of square root of n is a lot lot lot better
than O(n) algorithm, any big-oh of n algorithm.

00:06:42.450 --> 00:06:47.660
So, this was finding out all the factors of
a number. In the next lesson, we will see

00:06:47.660 --> 00:06:51.900
algorithm to find out prime factorization
of a number. So, thanks for Watching !

