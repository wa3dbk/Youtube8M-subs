WEBVTT
Kind: captions
Language: en

00:00:00.090 --> 00:00:02.130
JAMES CLEWETT: Absolutely
it's heavy.

00:00:02.130 --> 00:00:07.900
It is an antique 1980s
television.

00:00:07.900 --> 00:00:10.796
This is back from when
television was furniture.

00:00:10.796 --> 00:00:13.030
I love it.

00:00:13.030 --> 00:00:15.400
Well, this is my
first computer.

00:00:15.400 --> 00:00:18.580
This is a computer that my
parents had the foresight to

00:00:18.580 --> 00:00:20.210
buy me when I was
11 years old.

00:00:20.210 --> 00:00:23.840
It gave me a curiosity about
mathematics and physics, which

00:00:23.840 --> 00:00:25.300
has never really gone away.

00:00:25.300 --> 00:00:28.400
Today I'm going to talk
about the number 15.

00:00:28.400 --> 00:00:31.810
And I want to tell you that if
you're a computer geek like

00:00:31.810 --> 00:00:35.140
me, we don't really think
of the number 15 as 15.

00:00:35.140 --> 00:00:37.040
We think of it as the
letter F, and I'm

00:00:37.040 --> 00:00:38.290
going to tell you why.

00:00:41.000 --> 00:00:42.470
Right, you've got to
get this sound.

00:00:42.470 --> 00:00:45.593
This just makes such a fantastic
switch-on sound.

00:00:45.593 --> 00:00:46.595
[BEEP]

00:00:46.595 --> 00:00:49.370
Isn't that satisfying?

00:00:49.370 --> 00:00:51.580
So all I'm going to do is write
a short piece of code

00:00:51.580 --> 00:00:52.810
that makes the computer count.

00:00:52.810 --> 00:00:57.210
I'm rather pleased with myself
that I can still remember how

00:00:57.210 --> 00:00:58.150
to do this.

00:00:58.150 --> 00:00:59.500
Tah-dah!

00:00:59.500 --> 00:01:06.296
So all I'm doing is just
counting 1, 2, 3, 4, 5, 6, 7,

00:01:06.296 --> 00:01:09.320
8, 9, and then something
rather odd happens.

00:01:09.320 --> 00:01:14.460
And instead of counting to 10,
the computer switches to A, B,

00:01:14.460 --> 00:01:19.234
C, D, E, F, and then 10.

00:01:19.234 --> 00:01:20.740
11, 12, 13.

00:01:20.740 --> 00:01:23.492
And again it happens at 19.

00:01:23.492 --> 00:01:29.280
1A, 1B, C, D, E, F. 20.

00:01:29.280 --> 00:01:30.320
How bizarre.

00:01:30.320 --> 00:01:31.360
I was baffled.

00:01:31.360 --> 00:01:35.710
I was 11 years old, and we used
to have to wait for games

00:01:35.710 --> 00:01:37.050
to load from cassettes.

00:01:37.050 --> 00:01:39.570
And when they loaded, they would
count, and that would

00:01:39.570 --> 00:01:41.510
take maybe 10 minutes.

00:01:41.510 --> 00:01:45.770
And so I would be watching
these numbers count, very

00:01:45.770 --> 00:01:48.710
patiently waiting to play
Pac-Man or Tetris or whatever

00:01:48.710 --> 00:01:54.650
game I was playing that day, and
wondering precisely why it

00:01:54.650 --> 00:01:56.550
wasn't just getting on with
it and getting to 10.

00:01:56.550 --> 00:01:58.720
You know, why did it have to
go through-- it felt like

00:01:58.720 --> 00:02:00.860
torture, because I wanted
to play the game.

00:02:00.860 --> 00:02:01.370
Get on with it.

00:02:01.370 --> 00:02:01.990
Count to 10.

00:02:01.990 --> 00:02:04.520
But no, we had to go A through
F, first of all.

00:02:04.520 --> 00:02:07.610
So what we need to remember is
that computers don't count the

00:02:07.610 --> 00:02:10.020
way you and I count
on our fingers.

00:02:10.020 --> 00:02:14.010
They count on lines representing
ones and zeroes,

00:02:14.010 --> 00:02:15.210
binary numbers.

00:02:15.210 --> 00:02:18.270
So what I want to show you is
just four lines, first of all,

00:02:18.270 --> 00:02:30.100
and the number 0, the number 1,
the number 2, the number 3.

00:02:30.100 --> 00:02:32.970
And then I'm going
to skip a few.

00:02:32.970 --> 00:02:38.100
Down here we're going to
go to the number 14.

00:02:38.100 --> 00:02:41.870
And the number 15.

00:02:41.870 --> 00:02:45.060
OK, so there's quite a few
numbers in between, which we

00:02:45.060 --> 00:02:46.660
skipped over for brevity.

00:02:46.660 --> 00:02:54.740
So this is 0, 1, 2, 3, 14, 15.

00:02:54.740 --> 00:02:56.710
And I have to stop there.

00:02:56.710 --> 00:02:59.680
I have to stop there because
we've run out of numbers.

00:02:59.680 --> 00:03:02.680
If I try and count to a higher
number, that means that's got

00:03:02.680 --> 00:03:05.890
to be 0, 0, 0, 0, 1.

00:03:05.890 --> 00:03:07.720
But I don't have space
for this one here.

00:03:07.720 --> 00:03:09.730
And so we can't count
to a number bigger

00:03:09.730 --> 00:03:11.650
than 15 on four bits.

00:03:11.650 --> 00:03:14.470
The thing is, if you want to
understand the underlying ones

00:03:14.470 --> 00:03:18.340
and zeroes that's going on in a
computer, then I need to be

00:03:18.340 --> 00:03:22.150
able to very quickly say
what is this number?

00:03:22.150 --> 00:03:23.940
And this number, unfortunately,
bears very

00:03:23.940 --> 00:03:27.160
little relationship to
the decimal value.

00:03:27.160 --> 00:03:31.660
So, for example, the number
9, this is the

00:03:31.660 --> 00:03:33.550
number 9 for a computer.

00:03:33.550 --> 00:03:38.650
So the number 11, that's
number 11, OK?

00:03:38.650 --> 00:03:45.270
Or the number 6, for example,
would be 0, 1, 1, 0, number 6.

00:03:45.270 --> 00:03:49.060
So what we do instead is we
count in a thing called

00:03:49.060 --> 00:03:49.700
hexadecimal.

00:03:49.700 --> 00:03:51.120
This is base 16.

00:03:51.120 --> 00:03:55.960
So if we had 16 fingers, then
we would have come up with

00:03:55.960 --> 00:03:58.380
numbers sufficient to
go from 1 to 16.

00:03:58.380 --> 00:04:01.050
But because we only have 10
fingers, we only have 10

00:04:01.050 --> 00:04:02.550
digits for counting.

00:04:02.550 --> 00:04:06.610
And so instead of using just
more digits, we used letters

00:04:06.610 --> 00:04:08.170
to replace the missing digits.

00:04:08.170 --> 00:04:10.650
So let's start at the
number 8, and we'll

00:04:10.650 --> 00:04:11.520
work our way through.

00:04:11.520 --> 00:04:16.202
So the number 8 is going
to be 1, 0, 0, 0.

00:04:16.202 --> 00:04:17.550
That's 8.

00:04:17.550 --> 00:04:20.550
The number 9, 1, 0, 0, 1.

00:04:20.550 --> 00:04:21.880
That's 9.

00:04:21.880 --> 00:04:25.700
And then the number
10, that's 10.

00:04:25.700 --> 00:04:29.060
Now, notice that in decimal,
we've had to go into a new

00:04:29.060 --> 00:04:31.050
column for the number 10.

00:04:31.050 --> 00:04:35.210
But if we're working in
hexadecimal, then this is 8,

00:04:35.210 --> 00:04:39.430
9, and then this becomes
the letter a.

00:04:39.430 --> 00:04:44.780
And then 11, that's 11,
and it's the letter b.

00:04:44.780 --> 00:04:46.540
Then we're just going to skip to
the end, and it's going to

00:04:46.540 --> 00:04:52.110
be 1, 1, 1, 1, which is the
number 15, or in our case, the

00:04:52.110 --> 00:04:55.030
letter f, our magic number.

00:04:55.030 --> 00:04:57.880
OK, this is magic because it
allows us as programmers to

00:04:57.880 --> 00:05:01.690
very quickly see what's going
on with the binary numbers,

00:05:01.690 --> 00:05:04.080
the electronics inside
the computer.

00:05:04.080 --> 00:05:08.680
So in an 8-bit computer, we've
got two sets of 4-bit sets.

00:05:08.680 --> 00:05:15.430
So the number 0 becomes 0,
0, 0, 0, 0, 0, 0, 0.

00:05:15.430 --> 00:05:17.460
Two lots of four bits.

00:05:17.460 --> 00:05:23.150
Now, this set can be represented
by one hexadecimal

00:05:23.150 --> 00:05:24.730
digit, the letter 0.

00:05:24.730 --> 00:05:27.570
And just to let you know that
it's hexadecimal, I'm just

00:05:27.570 --> 00:05:29.220
going to write an X
in front of it.

00:05:29.220 --> 00:05:32.480
And this lot can similarly
be represented by the

00:05:32.480 --> 00:05:35.810
hexadecimal number 0.

00:05:35.810 --> 00:05:39.160
So this is 10, and this is 10.

00:05:39.160 --> 00:05:42.300
But in hexadecimal, we can
still represent this by a

00:05:42.300 --> 00:05:43.610
single character.

00:05:43.610 --> 00:05:50.310
This becomes a, and
this becomes a.

00:05:50.310 --> 00:05:54.760
In hexadecimal, our number is a,
a, with a little x in front

00:05:54.760 --> 00:05:57.330
of it, just to tell you that
it's a hexadecimal number.

00:05:57.330 --> 00:06:00.590
So I'm going to skip to the crux
of the issue, and that is

00:06:00.590 --> 00:06:03.520
the top number that we can
store in an 8-bit value,

00:06:03.520 --> 00:06:08.880
which, of course, is simply
1, 1, 1, 1, 1, 1, 1, 1.

00:06:08.880 --> 00:06:09.390
MALE SPEAKER: What
number is that?

00:06:09.390 --> 00:06:11.120
JAMES CLEWETT: And
that number is--

00:06:11.120 --> 00:06:13.110
this is f.

00:06:13.110 --> 00:06:14.180
This is f.

00:06:14.180 --> 00:06:17.200
So we've got the hexadecimal
number ff, which is equal to

00:06:17.200 --> 00:06:21.830
255, which is the highest
value that an 8-bit

00:06:21.830 --> 00:06:24.220
computer can store.

00:06:24.220 --> 00:06:26.650
OK, now, course, modern
computers aren't

00:06:26.650 --> 00:06:29.160
simply eight bits long.

00:06:29.160 --> 00:06:31.990
Recently, 32 bits, or you can
go out and you can buy a

00:06:31.990 --> 00:06:33.620
top-end 64-bit computer.

00:06:33.620 --> 00:06:36.510
So I want to show you the
highest number in very

00:06:36.510 --> 00:06:39.690
shorthand notation that a 32-bit
computer can store.

00:06:39.690 --> 00:06:41.060
Here we go.

00:06:41.060 --> 00:06:50.205
ff, ff, ff, ff, so 8 bits, 16
bits, 24 bits, 32 bits.

00:06:50.205 --> 00:06:51.460
Now I'll write that in binary.

00:06:51.460 --> 00:06:53.070
How I hate you.

00:06:53.070 --> 00:07:00.970
1111, 1111, 1111, 1111, 1111--

00:07:00.970 --> 00:07:02.360
I'm going to have to put
a few on the front.

00:07:05.130 --> 00:07:09.000
And that is the binary number 1,
1, 1, 1, 1, 1, 1, 1, 1, 1,

00:07:09.000 --> 00:07:10.200
1, 1, 1, 1.

00:07:10.200 --> 00:07:10.920
You get the idea.

00:07:10.920 --> 00:07:12.370
It's a big number.

00:07:12.370 --> 00:07:14.350
And that's why we don't
use binary.

00:07:14.350 --> 00:07:16.260
We use hexadecimal values.

00:07:16.260 --> 00:07:17.900
Obviously, if I wanted to write
a really big number

00:07:17.900 --> 00:07:20.420
down, it's just too much
pen and ink, so we

00:07:20.420 --> 00:07:22.220
don't use the binary.

00:07:22.220 --> 00:07:25.900
We don't use decimal because,
well, this number, it's not

00:07:25.900 --> 00:07:30.270
65,000, it's approximately
4 billion.

00:07:30.270 --> 00:07:31.990
This has no relationship
to 4 billion.

00:07:31.990 --> 00:07:35.140
There's no obvious way to tie
the two things together.

00:07:35.140 --> 00:07:37.800
But when we're using the
hexadecimal numbers, each

00:07:37.800 --> 00:07:42.540
character is simply tied to a
block of four binary values.

00:07:42.540 --> 00:07:45.710
So this character represents the
first four, this character

00:07:45.710 --> 00:07:46.580
the next four.

00:07:46.580 --> 00:07:49.740
And so it's very easy to just
walk along, understanding the

00:07:49.740 --> 00:07:52.220
number in human readable
chunks.

