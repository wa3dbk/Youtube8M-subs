WEBVTT
Kind: captions
Language: it

00:00:00.729 --> 00:00:06.540
Buona giornata ragazzi! Oggi sostituisco il
prof. Eddie! E visto che sono libero di scegliere,

00:00:06.540 --> 00:00:11.610
vorrei proprio parlarvi del sistema di numerazione
binario, conosciuto anche come codice binario!

00:00:11.610 --> 00:00:17.280
E che roba è? Il modo in cui contano i treni!
Ahahah

00:00:17.280 --> 00:00:21.600
Sai che non ci sei andato molto lontano Moretti?
Il codice binario è il sistema di numerazione

00:00:21.609 --> 00:00:26.150
usato da tutti i computer anche quelli che
regolano i moderni treni. Ma il motivo per

00:00:26.150 --> 00:00:32.119
cui si chiama binario è che utilizza solo
due simboli numerici, lo 0 e l’1. È quindi

00:00:32.119 --> 00:00:38.800
un sistema di numerazione a base 2.
Aho interessante! Solo due numeri, ma è un

00:00:38.800 --> 00:00:43.930
sogno! Niente più espressioni kilometriche....
ahahah Moretti, mi dispiace deluderti, ma

00:00:43.930 --> 00:00:48.680
dato che si utilizzano solo due simboli per
rappresentare ogni cosa in numeri binari solitamente

00:00:48.680 --> 00:00:52.460
utilizzano delle sequenze molto più lunghe
di quelle che utilizziamo abitualmente..

00:00:52.460 --> 00:00:57.280
Ecco, mai na gioia dalla mate...
Vediamo come convertire un numero da base

00:00:57.280 --> 00:01:01.879
10 a base 2, utilizzando gli stessi metodi
che vi ha già spiegato il Prof.Eddie nelle

00:01:01.879 --> 00:01:06.480
precedenti lezioni. Utilizziamo ad esempio
il metodo grafico per rappresentare il numero

00:01:06.480 --> 00:01:12.170
19, quindi 19 pallini. Raggruppiamoli in gruppi
da 2 e scriviamo il numero di pallini che

00:01:12.170 --> 00:01:19.170
ne restano fuori, in questo caso 1. Vedete
che possono rimanerne fuori o 0 o 1 che sono

00:01:19.210 --> 00:01:23.940
per l’appunto le due cifre utilizzate per
rappresentare il numero in sistema binario.

00:01:23.940 --> 00:01:29.860
Ora riportiamo un pallino per ciascun gruppo
completo, quindi 9 pallini. Formiamo di nuovo

00:01:29.860 --> 00:01:37.040
i gruppi da 2 e segnamo di nuovo 1. Per ogni
gruppo riportiamo un pallino, quindi 4 e formiamo

00:01:37.050 --> 00:01:42.830
i nostri gruppi a base 2. Questa volta non
ne resta nessuno fuori quindi scriviamo 0.

00:01:42.830 --> 00:01:47.700
Scriviamo di nuovo un pallino per ogni gruppo
precedentemente completetato, 2 pallini e

00:01:47.700 --> 00:01:53.840
raggruppiamoli. Anche questa volta ne restano
fuori 0. Infine rimane un solo pallino, e

00:01:53.840 --> 00:01:58.680
quindi scriviamo 1.
quindi il numero 19 in base 10, riscritto

00:01:58.680 --> 00:02:06.560
in base due sarà uno zero zero uno uno?
Prorpio così! Scriviamolo in notazione polinomiale.

00:02:06.560 --> 00:02:15.459
Avremo 1 per 2 alla 4 + 0 per 2 alla 3 + 0
per 2 al quadrato + 1 per 2 alla 1 + 1 per

00:02:15.459 --> 00:02:21.060
2 alla 0. In cui gli esponenti della base
due hanno valori crescenti partenti da zero,

00:02:21.060 --> 00:02:27.730
da sinistra a destra. Svolgiamo le potenze
e facciamo i prodotti ottenedo 16 + 0 + 0

00:02:27.730 --> 00:02:33.739
+ 2 + 1, che è uguale proprio a 19.
Vabbè sta lezione è noiosa proprio come

00:02:33.739 --> 00:02:37.849
le altre del Prof..
Mmmm, vediamo un’applicazione più realistica

00:02:37.849 --> 00:02:42.489
allora…. Vi sarà capitato qualche volte
di leggere sui vostri lettori mp3 o sulle

00:02:42.489 --> 00:02:47.680
schede delle vostre fotocamere digitali la
memoria espressa in gigabyte e poi vedete

00:02:47.680 --> 00:02:51.540
che questa non corrispondeva esattamente a
quella che avevate a disposizione.

00:02:51.540 --> 00:02:57.189
è vero! Nella mia nuova scheda di memoria
c’è scritto sopra 200 GB, ma in realtà

00:02:57.189 --> 00:03:00.180
sono di meno!
Per capire il perchè vediamo prima quale

00:03:00.180 --> 00:03:04.609
è l’unità di misura della memoria. Per
i computer e tutti i dispositivi elettronici

00:03:04.609 --> 00:03:09.900
le informazioni vengono immagazzinate in codice
binario sotto forma di bit, dall’inglese

00:03:09.900 --> 00:03:15.900
binary digit. Ogni bit può assumere valore
0 o 1. Solitamente si utilizzano sequenze

00:03:15.900 --> 00:03:21.420
di 8 bit chiamate Byte. Il byte ha tutta una
serie di multipli che utilizzano gli stessi

00:03:21.420 --> 00:03:27.920
prefissi del sistema decimale: kilo che sta
per 10 alla 3, cioè 1000, mega 10 alla 6,

00:03:27.920 --> 00:03:32.430
cioè 1 milione e giga, 10 alla 9 cioè 1
miliardo.

00:03:32.430 --> 00:03:37.069
però dato che si tratta di un sistema binario
le cose sono un po’ differenti. Infatti

00:03:37.069 --> 00:03:43.810
un kilobyte sono 2 alla 10 byte cioè 1024,
leggermente maggiore del kilo decimale. Così

00:03:43.810 --> 00:03:49.540
anche il megabyte è 2 alla 20, maggiore del
corrispettivo decimale ed anche il gigabyte

00:03:49.540 --> 00:03:55.799
che è 2 alla 30. Vedete che quella piccola
differenza di 24 nel kilobyte, salendo fino

00:03:55.799 --> 00:03:59.969
al gigabyte diventa una differenza di oltre
73 milioni di byte!

00:03:59.969 --> 00:04:04.829
non capisco proprio dove vogliamo arrivare...E quindi questo crea un po' di confusione.

00:04:04.829 --> 00:04:10.739
Se abbiamo un dispositivo con una memoria
di 200 GB, cioè 200 miliardi di byte dividendo

00:04:10.739 --> 00:04:16.389
per il valore del prefisso giga decimale otterremo
come è facile aspettarci di nuovo 200. Ma

00:04:16.389 --> 00:04:20.100
dato che il byte è in codice binario, la
giusta operazione sarebbe dividere per il

00:04:20.100 --> 00:04:28.560
valore in giga binario cioè 1 miliardo 73
milioni 741 mila e 824 byte. Da questa divisione

00:04:28.570 --> 00:04:31.910
si vede che in realtà i 200 GB sono solo
186.

00:04:31.910 --> 00:04:38.170
Aaaah ho capito. In realtà non mancano 14
gigabyte alla mia scheda di memoria, ma si

00:04:38.170 --> 00:04:42.910
tratta solo di un modo errato di indicarli!
Proprio così Giovanna! Tutto chiaro quindi?

