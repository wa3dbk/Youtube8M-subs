WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.130
 I'm going to explain to you a way to calculate 

00:00:02.220 --> 00:00:07.830
 the prime numbers the example I'm going to 

00:00:05.130 --> 00:00:09.870
 perform in visual cesar 

00:00:07.830 --> 00:00:11.790
 the prime numbers are all those 

00:00:09.870 --> 00:00:15.430
 natural numbers that are only 

00:00:11.790 --> 00:00:17.830
 divisible among themselves and between 1 

00:00:15.430 --> 00:00:20.590
 remember that a couple of numbers is 

00:00:17.830 --> 00:00:24.410
 divisible if your division is accurate is 

00:00:20.590 --> 00:00:27.710
 say that by dividing them they leave no residue 

00:00:24.410 --> 00:00:31.350
 for example 10 is divisible by 5 

00:00:27.710 --> 00:00:35.220
 its division is exact and its remainder is 0 

00:00:31.350 --> 00:00:37.380
 an example of non-divisible numbers 23 

00:00:35.220 --> 00:00:38.910
 is not divisible by 7 since at 

00:00:37.380 --> 00:00:41.610
 divide them we have a residue 

00:00:38.910 --> 00:00:44.020
 different from 0 therefore it is a 

00:00:41.610 --> 00:00:46.430
 not exact division 

00:00:44.020 --> 00:00:48.650
 normally to the residue of dividing the 

00:00:46.430 --> 00:00:51.650
 The numerator between the divisor is usually 

00:00:48.650 --> 00:00:54.200
 express follows the 

00:00:51.650 --> 00:00:56.690
 schedule in Caesar if we want to get 

00:00:54.200 --> 00:01:00.660
 the waste we should use the operator 

00:00:56.690 --> 00:01:02.970
 module which is the percentage character 

00:01:00.660 --> 00:01:05.040
 to know if a number is a prime number 

00:01:02.970 --> 00:01:08.250
 we must check that there are only two 

00:01:05.040 --> 00:01:11.220
 dividers for example if we want to know 

00:01:08.250 --> 00:01:15.680
 if 5 is a prime number we verify 

00:01:11.220 --> 00:01:15.680
 how many divisors are there from 1 to 5 

00:01:15.830 --> 00:01:21.950
 we can see that there are only two divisors 1 

00:01:18.980 --> 00:01:23.870
 and 5 that means there are only two 

00:01:21.950 --> 00:01:27.260
 exact divisions 

00:01:23.870 --> 00:01:29.630
 therefore 5 if it is a prime number the 

00:01:27.260 --> 00:01:31.760
 other divisors than 1 and 5 

00:01:29.630 --> 00:01:33.580
 they had a different number as residue 

00:01:31.760 --> 00:01:36.010
 of 0 

00:01:33.580 --> 00:01:37.690
 when we schedule we just have to 

00:01:36.010 --> 00:01:41.110
 check if there are more than two divisions 

00:01:37.690 --> 00:01:43.360
 Exactly we would do tests from the number 

00:01:41.110 --> 00:01:45.180
 2 up to a number before the number a 

00:01:43.360 --> 00:01:47.340
 check 

00:01:45.180 --> 00:01:50.160
 now let's see an example of number no 

00:01:47.340 --> 00:01:53.670
 cousin the number 6 is not prime number 

00:01:50.160 --> 00:01:58.150
 because it has more than two divisors 6 3 2 

00:01:53.670 --> 00:02:00.730
 and 1 that is, there are 4 exact divisions 

00:01:58.150 --> 00:02:02.470
 But to know if a number is prime, 

00:02:00.730 --> 00:02:04.930
 It is necessary to find all your 

00:02:02.470 --> 00:02:07.090
 dividers you have to discard the 

00:02:04.930 --> 00:02:10.300
 end splitters that in this 

00:02:07.090 --> 00:02:12.520
 case are 1 and 6 find the first divisor 

00:02:10.300 --> 00:02:14.920
 with the module operator and at the time 

00:02:12.520 --> 00:02:16.710
 that the first residue 0 is found 

00:02:14.920 --> 00:02:19.600
 You can consider it as a non-prime number 

00:02:16.710 --> 00:02:21.850
 as you can see by just checking that 

00:02:19.600 --> 00:02:24.040
 the remainder of 6 between 2 is 0 

00:02:21.850 --> 00:02:26.640
 from that moment the 6 is discarded as 

00:02:24.040 --> 00:02:26.640
 prime number 

00:02:27.050 --> 00:02:32.780
 Well now I'm going to program a bit in 

00:02:29.750 --> 00:02:35.710
 visual caesar I'm going to add a box of 

00:02:32.780 --> 00:02:35.710
 text and a button 

00:02:38.450 --> 00:02:43.610
 I'm going to write a little program for 

00:02:40.940 --> 00:02:45.440
 know if a number is prime number the 

00:02:43.610 --> 00:02:48.620
 number to check is going to be the variable 

00:02:45.440 --> 00:02:51.530
 x the variable volea na is prime will indicate 

00:02:48.620 --> 00:02:53.540
 if the variable x that does not prime number yes 

00:02:51.530 --> 00:02:56.630
 is cousin is true and if it is not cousin it is 

00:02:53.540 --> 00:02:58.819
 false the method that I'm going to use is 

00:02:56.630 --> 00:03:01.040
 know if there are exact divisions without 

00:02:58.819 --> 00:03:02.959
 touch one and the value of x I'm going to 

00:03:01.040 --> 00:03:05.290
 start with the assumption that it is 

00:03:02.959 --> 00:03:05.290
 cousin 

00:03:05.420 --> 00:03:09.380
 with a force structure the 

00:03:07.550 --> 00:03:12.080
 verification from 2 to a value 

00:03:09.380 --> 00:03:15.170
 before x the local variable and 

00:03:12.080 --> 00:03:18.770
 will increase by 1 for each iteration with 

00:03:15.170 --> 00:03:21.920
 which we will do verifications with 2 3 4 

00:03:18.770 --> 00:03:24.350
 and so until you reach x without touching it 

00:03:21.920 --> 00:03:27.230
 we start with 1 well this one naturally 

00:03:24.350 --> 00:03:29.959
 it's a divisor what we're looking for is 

00:03:27.230 --> 00:03:32.239
 know if there are intermediate dividers the 

00:03:29.959 --> 00:03:34.450
 which can discard ax as number 

00:03:32.239 --> 00:03:34.450
 cousin 

00:03:35.040 --> 00:03:40.890
 then enter a 

00:03:37.290 --> 00:03:43.439
 conditional if the value of x module y is 

00:03:40.890 --> 00:03:45.780
 0 this will indicate that at that point there is a 

00:03:43.439 --> 00:03:48.390
 exact division as the residue of that 

00:03:45.780 --> 00:03:50.879
 division is 0 therefore there will be more than 

00:03:48.390 --> 00:03:53.040
 2 divisors that consequently we 

00:03:50.879 --> 00:03:55.859
 will indicate that this value of x is not a 

00:03:53.040 --> 00:03:58.170
 prime number once it's cousin take 

00:03:55.859 --> 00:04:00.060
 the value of false we left the cycle 

00:03:58.170 --> 00:04:03.090
 for with a break because we have finished 

00:04:00.060 --> 00:04:05.639
 checking in case the value 

00:04:03.090 --> 00:04:07.290
 of x is a prime number the flow of 

00:04:05.639 --> 00:04:09.359
 program will not pass the block the 

00:04:07.290 --> 00:04:12.859
 condition and the value of 

00:04:09.359 --> 00:04:12.859
 'true initially assigned 

00:04:17.049 --> 00:04:22.479
 well now we will show the result in 

00:04:19.690 --> 00:04:24.610
 the concatenate text box we have the 

00:04:22.479 --> 00:04:27.280
 result with several text strings 

00:04:24.610 --> 00:04:30.220
 to show the result we will use 

00:04:27.280 --> 00:04:32.889
 a ternary operator if it is prime is true 

00:04:30.220 --> 00:04:35.860
 s concatenated as a result if it is a 

00:04:32.889 --> 00:04:37.780
 prime number otherwise if it is 

00:04:35.860 --> 00:04:41.759
 cousin is false is concatenated as 

00:04:37.780 --> 00:04:41.759
 result is not a prime number 

00:04:46.310 --> 00:04:51.920
 now let's run the program with the 

00:04:48.350 --> 00:04:55.850
 example as the value of x is 4 and being 

00:04:51.920 --> 00:04:58.180
 divisible with 12 and 4 therefore it is not 

00:04:55.850 --> 00:04:58.180
 cousin 

00:05:03.380 --> 00:05:10.330
 all right now we change the value of x by 5 

00:05:07.750 --> 00:05:12.700
 when we run the program we can 

00:05:10.330 --> 00:05:16.710
 see that 5 if it is a prime number then 

00:05:12.700 --> 00:05:16.710
 it is only divisible between 1 and 5 

00:05:18.100 --> 00:05:22.720
 modify the program so that now 

00:05:20.410 --> 00:05:25.630
 show the prime numbers that there are from 

00:05:22.720 --> 00:05:28.150
 the 2 to 1000 the variable n will be the 

00:05:25.630 --> 00:05:32.220
 cap to 1000 in the string primes are 

00:05:28.150 --> 00:05:32.220
 they will keep the prime numbers found 

00:05:34.830 --> 00:05:38.850
 to go through the numbers from 1 to 1000 

00:05:37.200 --> 00:05:40.650
 we will do it with a for cycle 

00:05:38.850 --> 00:05:42.660
 increment of 1 

00:05:40.650 --> 00:05:44.730
 now x will become a variable 

00:05:42.660 --> 00:05:47.480
 local del force and it will work as 

00:05:44.730 --> 00:05:47.480
 increase dor 

00:05:51.160 --> 00:05:56.050
 here at this point if the value of x happens 

00:05:54.100 --> 00:05:58.750
 the proof of being a prime number is 

00:05:56.050 --> 00:06:00.880
 add to the list of prime numbers in 

00:05:58.750 --> 00:06:02.980
 if conditional only if he is a cousin 

00:06:00.880 --> 00:06:07.230
 has the value of true and concatenates the 

00:06:02.980 --> 00:06:07.230
 value of x with the text string cousins 

00:06:11.600 --> 00:06:17.200
 finally we show the result in the 

00:06:14.270 --> 00:06:17.200
 text box 

00:06:23.080 --> 00:06:28.479
 well just need to try the program at 

00:06:26.710 --> 00:06:30.340
 execute we can see that if you 

00:06:28.479 --> 00:06:32.449
 they calculate the prime numbers well 

00:06:30.340 --> 00:06:34.759
 from 2 to 1000 

00:06:32.449 --> 00:06:36.740
 I hope you have explained me well and that 

00:06:34.759 --> 00:06:40.219
 this tutorial that I have 

00:06:36.740 --> 00:06:42.639
 I am Iván Martial Pérez until the 

00:06:40.219 --> 00:06:42.639
 next 

