WEBVTT
Kind: captions
Language: en

00:00:01.639 --> 00:00:04.610 

to<00:00:02.639> use<00:00:02.820> numbers<00:00:03.270> responsibly<00:00:03.840> you<00:00:04.440> should

00:00:04.610 --> 00:00:04.620 
to use numbers responsibly you should

00:00:04.620 --> 00:00:06.610 
to use numbers responsibly you should
learn<00:00:04.740> the<00:00:04.799> rules<00:00:05.160> of<00:00:05.339> arithmetic<00:00:05.850> addition

00:00:06.610 --> 00:00:06.620 
learn the rules of arithmetic addition

00:00:06.620 --> 00:00:09.220 
learn the rules of arithmetic addition
subtraction<00:00:07.620> multiplication<00:00:08.099> and<00:00:08.610> division

00:00:09.220 --> 00:00:09.230 
subtraction multiplication and division

00:00:09.230 --> 00:00:11.749 
subtraction multiplication and division
arithmetic<00:00:10.230> may<00:00:10.679> seem<00:00:10.950> trivial<00:00:11.099> but<00:00:11.550> some

00:00:11.749 --> 00:00:11.759 
arithmetic may seem trivial but some

00:00:11.759 --> 00:00:13.310 
arithmetic may seem trivial but some
complications<00:00:12.420> arise<00:00:12.690> when<00:00:12.900> you<00:00:12.990> combine

00:00:13.310 --> 00:00:13.320 
complications arise when you combine

00:00:13.320 --> 00:00:15.799 
complications arise when you combine
numbers<00:00:13.679> of<00:00:13.860> different<00:00:13.980> types<00:00:14.309> in<00:00:14.580> this<00:00:15.450> video

00:00:15.799 --> 00:00:15.809 
numbers of different types in this video

00:00:15.809 --> 00:00:17.510 
numbers of different types in this video
we'll<00:00:16.289> cover<00:00:16.440> arithmetic<00:00:17.039> in<00:00:17.160> Version<00:00:17.490> three

00:00:17.510 --> 00:00:17.520 
we'll cover arithmetic in Version three

00:00:17.520 --> 00:00:20.599 
we'll cover arithmetic in Version three
if<00:00:18.420> you're<00:00:18.750> using<00:00:18.990> Python<00:00:19.470> version<00:00:19.500> two<00:00:19.980> then

00:00:20.599 --> 00:00:20.609 
if you're using Python version two then

00:00:20.609 --> 00:00:22.269 
if you're using Python version two then
you'll<00:00:20.760> want<00:00:21.000> to<00:00:21.060> watch<00:00:21.270> our<00:00:21.449> other<00:00:21.480> video

00:00:22.269 --> 00:00:22.279 
you'll want to watch our other video

00:00:22.279 --> 00:00:30.380 
you'll want to watch our other video
version<00:00:23.279> through<00:00:23.430> arithmetic<00:00:23.939> begins<00:00:24.539> now<00:00:29.390> in

00:00:30.380 --> 00:00:30.390 
version through arithmetic begins now in

00:00:30.390 --> 00:00:32.389 
version through arithmetic begins now in
Python<00:00:31.080> version<00:00:31.109> three<00:00:31.679> there<00:00:32.099> are<00:00:32.189> three

00:00:32.389 --> 00:00:32.399 
Python version three there are three

00:00:32.399 --> 00:00:33.319 
Python version three there are three
types<00:00:32.640> of<00:00:32.850> numbers

00:00:33.319 --> 00:00:33.329 
types of numbers

00:00:33.329 --> 00:00:36.740 
types of numbers
intz<00:00:34.050> floats<00:00:34.530> and<00:00:34.770> complex<00:00:35.250> numbers<00:00:35.640> and<00:00:35.880> an

00:00:36.740 --> 00:00:36.750 
intz floats and complex numbers and an

00:00:36.750 --> 00:00:38.389 
intz floats and complex numbers and an
arithmetic<00:00:37.290> there<00:00:37.530> are<00:00:37.590> 4<00:00:37.770> operations

00:00:38.389 --> 00:00:38.399 
arithmetic there are 4 operations

00:00:38.399 --> 00:00:41.360 
arithmetic there are 4 operations
addition<00:00:39.239> subtraction<00:00:39.450> multiplication<00:00:40.379> and

00:00:41.360 --> 00:00:41.370 
addition subtraction multiplication and

00:00:41.370 --> 00:00:44.240 
addition subtraction multiplication and
division<00:00:41.600> to<00:00:42.600> use<00:00:42.780> arithmetic<00:00:43.350> in<00:00:43.469> Python<00:00:43.890> you

00:00:44.240 --> 00:00:44.250 
division to use arithmetic in Python you

00:00:44.250 --> 00:00:45.889 
division to use arithmetic in Python you
first<00:00:44.550> need<00:00:44.760> to<00:00:44.789> understand<00:00:45.329> the<00:00:45.450> idea<00:00:45.480> of

00:00:45.889 --> 00:00:45.899 
first need to understand the idea of

00:00:45.899 --> 00:00:49.549 
first need to understand the idea of
narrower<00:00:46.500> and<00:00:46.770> wider<00:00:47.039> types<00:00:47.430> any<00:00:48.379> Intel<00:00:49.379> you

00:00:49.549 --> 00:00:49.559 
narrower and wider types any Intel you

00:00:49.559 --> 00:00:51.889 
narrower and wider types any Intel you
can<00:00:49.950> also<00:00:50.100> be<00:00:50.309> represented<00:00:50.850> by<00:00:50.969> a<00:00:51.000> float<00:00:51.360> but

00:00:51.889 --> 00:00:51.899 
can also be represented by a float but

00:00:51.899 --> 00:00:54.139 
can also be represented by a float but
not<00:00:51.960> the<00:00:52.110> other<00:00:52.379> way<00:00:52.530> around<00:00:52.649> to<00:00:53.640> convert<00:00:54.000> an

00:00:54.139 --> 00:00:54.149 
not the other way around to convert an

00:00:54.149 --> 00:00:56.810 
not the other way around to convert an
int<00:00:54.390> to<00:00:54.600> a<00:00:54.719> float<00:00:54.780> just<00:00:55.559> add<00:00:55.800> a<00:00:55.829> point<00:00:56.160> 0<00:00:56.520> at<00:00:56.670> the

00:00:56.810 --> 00:00:56.820 
int to a float just add a point 0 at the

00:00:56.820 --> 00:00:59.569 
int to a float just add a point 0 at the
end<00:00:56.899> another<00:00:57.899> way<00:00:58.050> to<00:00:58.199> do<00:00:58.410> this<00:00:58.559> is<00:00:58.800> to<00:00:59.190> pass<00:00:59.399> an

00:00:59.569 --> 00:00:59.579 
end another way to do this is to pass an

00:00:59.579 --> 00:01:02.270 
end another way to do this is to pass an
integer<00:00:59.789> to<00:01:00.180> the<00:01:00.270> float<00:01:00.480> constructor<00:01:01.100> but<00:01:02.100> not

00:01:02.270 --> 00:01:02.280 
integer to the float constructor but not

00:01:02.280 --> 00:01:04.820 
integer to the float constructor but not
all<00:01:02.489> floats<00:01:02.789> can<00:01:03.030> be<00:01:03.120> converted<00:01:03.390> to<00:01:03.539> int<00:01:03.830> for

00:01:04.820 --> 00:01:04.830 
all floats can be converted to int for

00:01:04.830 --> 00:01:07.250 
all floats can be converted to int for
example<00:01:05.220> the<00:01:05.309> number<00:01:05.580> 3.14<00:01:06.570> is<00:01:06.750> a<00:01:06.810> decimal

00:01:07.250 --> 00:01:07.260 
example the number 3.14 is a decimal

00:01:07.260 --> 00:01:10.130 
example the number 3.14 is a decimal
it's<00:01:07.950> not<00:01:08.220> a<00:01:08.250> whole<00:01:08.520> number<00:01:08.729> if<00:01:09.030> you<00:01:09.900> try<00:01:10.080> to

00:01:10.130 --> 00:01:10.140 
it's not a whole number if you try to

00:01:10.140 --> 00:01:12.140 
it's not a whole number if you try to
change<00:01:10.439> it<00:01:10.590> to<00:01:10.710> an<00:01:10.799> INT<00:01:10.950> the<00:01:11.460> number<00:01:11.760> is<00:01:11.850> first

00:01:12.140 --> 00:01:12.150 
change it to an INT the number is first

00:01:12.150 --> 00:01:14.780 
change it to an INT the number is first
rounded<00:01:12.570> then<00:01:13.110> made<00:01:13.320> into<00:01:13.590> an<00:01:13.680> INT<00:01:13.860> it's<00:01:14.100> no

00:01:14.780 --> 00:01:14.790 
rounded then made into an INT it's no

00:01:14.790 --> 00:01:17.690 
rounded then made into an INT it's no
longer<00:01:15.150> the<00:01:15.270> same<00:01:15.450> number<00:01:15.840> so<00:01:16.740> we<00:01:16.920> say<00:01:17.159> in<00:01:17.340> are

00:01:17.690 --> 00:01:17.700 
longer the same number so we say in are

00:01:17.700 --> 00:01:20.330 
longer the same number so we say in are
narrower<00:01:18.180> than<00:01:18.509> floats<00:01:18.840> you<00:01:19.710> can<00:01:19.890> also<00:01:20.040> say

00:01:20.330 --> 00:01:20.340 
narrower than floats you can also say

00:01:20.340 --> 00:01:24.020 
narrower than floats you can also say
that<00:01:20.490> floats<00:01:20.759> are<00:01:20.970> wider<00:01:21.330> than<00:01:21.450> int<00:01:23.030> similarly

00:01:24.020 --> 00:01:24.030 
that floats are wider than int similarly

00:01:24.030 --> 00:01:25.820 
that floats are wider than int similarly
any<00:01:24.240> float<00:01:24.720> can<00:01:24.900> be<00:01:24.990> made<00:01:25.170> into<00:01:25.409> a<00:01:25.439> complex

00:01:25.820 --> 00:01:25.830 
any float can be made into a complex

00:01:25.830 --> 00:01:28.520 
any float can be made into a complex
number<00:01:26.070> but<00:01:26.490> not<00:01:26.670> vice<00:01:26.939> versa<00:01:27.200> to<00:01:28.200> convert<00:01:28.500> a

00:01:28.520 --> 00:01:28.530 
number but not vice versa to convert a

00:01:28.530 --> 00:01:31.609 
number but not vice versa to convert a
float<00:01:28.710> to<00:01:28.979> a<00:01:29.009> complex<00:01:29.369> number<00:01:29.520> just<00:01:30.329> add<00:01:30.509> 0j<00:01:31.320> to

00:01:31.609 --> 00:01:31.619 
float to a complex number just add 0j to

00:01:31.619 --> 00:01:34.069 
float to a complex number just add 0j to
the<00:01:31.740> number<00:01:32.009> or<00:01:32.549> pass<00:01:33.360> the<00:01:33.630> number<00:01:33.869> to<00:01:33.990> the

00:01:34.069 --> 00:01:34.079 
the number or pass the number to the

00:01:34.079 --> 00:01:36.590 
the number or pass the number to the
complex<00:01:34.439> constructor<00:01:35.040> if<00:01:35.299> you<00:01:36.299> try<00:01:36.540> to

00:01:36.590 --> 00:01:36.600 
complex constructor if you try to

00:01:36.600 --> 00:01:38.569 
complex constructor if you try to
convert<00:01:36.930> a<00:01:36.990> complex<00:01:37.350> number<00:01:37.560> to<00:01:37.799> a<00:01:37.829> float<00:01:38.130> you

00:01:38.569 --> 00:01:38.579 
convert a complex number to a float you

00:01:38.579 --> 00:01:41.630 
convert a complex number to a float you
get<00:01:38.790> a<00:01:38.820> type<00:01:39.090> error<00:01:39.470> so<00:01:40.470> floats<00:01:40.920> are<00:01:41.130> narrower

00:01:41.630 --> 00:01:41.640 
get a type error so floats are narrower

00:01:41.640 --> 00:01:44.030 
get a type error so floats are narrower
than<00:01:41.850> complex<00:01:42.270> numbers<00:01:42.659> we<00:01:43.470> can<00:01:43.590> also<00:01:43.740> say

00:01:44.030 --> 00:01:44.040 
than complex numbers we can also say

00:01:44.040 --> 00:01:45.499 
than complex numbers we can also say
that<00:01:44.070> complex<00:01:44.610> numbers<00:01:44.909> are<00:01:45.090> wider<00:01:45.360> than

00:01:45.499 --> 00:01:45.509 
that complex numbers are wider than

00:01:45.509 --> 00:01:47.539 
that complex numbers are wider than
floats

00:01:47.539 --> 00:01:47.549 
floats

00:01:47.549 --> 00:01:49.819 
floats
let's<00:01:48.299> now<00:01:48.509> explore<00:01:48.659> the<00:01:49.049> four<00:01:49.259> arithmetic

00:01:49.819 --> 00:01:49.829 
let's now explore the four arithmetic

00:01:49.829 --> 00:01:52.190 
let's now explore the four arithmetic
operations<00:01:50.310> in<00:01:50.399> Python<00:01:50.820> we'll<00:01:51.689> start<00:01:52.049> by

00:01:52.190 --> 00:01:52.200 
operations in Python we'll start by

00:01:52.200 --> 00:01:54.649 
operations in Python we'll start by
creating<00:01:52.259> three<00:01:52.799> numbers<00:01:53.219> one<00:01:53.880> for<00:01:54.210> each<00:01:54.329> type

00:01:54.649 --> 00:01:54.659 
creating three numbers one for each type

00:01:54.659 --> 00:01:59.749 
creating three numbers one for each type
a<00:01:54.950> is<00:01:55.950> an<00:01:56.159> int<00:01:56.479> B<00:01:57.479> is<00:01:57.719> a<00:01:57.780> float<00:01:58.170> and<00:01:58.520> C<00:01:59.520> is<00:01:59.700> a

00:01:59.749 --> 00:01:59.759 
a is an int B is a float and C is a

00:01:59.759 --> 00:02:02.660 
a is an int B is a float and C is a
complex<00:02:00.030> number<00:02:00.829> the<00:02:01.829> rule<00:02:02.009> of<00:02:02.159> thumb<00:02:02.340> is<00:02:02.520> when

00:02:02.660 --> 00:02:02.670 
complex number the rule of thumb is when

00:02:02.670 --> 00:02:04.370 
complex number the rule of thumb is when
combining<00:02:03.179> two<00:02:03.359> numbers<00:02:03.719> of<00:02:03.869> different<00:02:04.020> types

00:02:04.370 --> 00:02:04.380 
combining two numbers of different types

00:02:04.380 --> 00:02:06.559 
combining two numbers of different types
Python<00:02:05.189> will<00:02:05.340> convert<00:02:05.640> the<00:02:05.729> narrower<00:02:06.060> type<00:02:06.360> to

00:02:06.559 --> 00:02:06.569 
Python will convert the narrower type to

00:02:06.569 --> 00:02:08.210 
Python will convert the narrower type to
the<00:02:06.600> wider<00:02:06.899> type<00:02:07.259> then<00:02:07.740> perform<00:02:08.160> the

00:02:08.210 --> 00:02:08.220 
the wider type then perform the

00:02:08.220 --> 00:02:13.640 
the wider type then perform the
operation<00:02:09.440> addition<00:02:10.459> if<00:02:11.459> we<00:02:12.120> add<00:02:12.450> a<00:02:12.629> and<00:02:13.019> B<00:02:13.319> we

00:02:13.640 --> 00:02:13.650 
operation addition if we add a and B we

00:02:13.650 --> 00:02:16.400 
operation addition if we add a and B we
are<00:02:13.680> adding<00:02:14.069> an<00:02:14.160> INT<00:02:14.430> and<00:02:14.580> a<00:02:14.760> float<00:02:15.200> floats<00:02:16.200> are

00:02:16.400 --> 00:02:16.410 
are adding an INT and a float floats are

00:02:16.410 --> 00:02:18.559 
are adding an INT and a float floats are
wider<00:02:16.620> than<00:02:16.739> intz<00:02:17.220> so<00:02:17.580> python<00:02:17.970> converts<00:02:18.330> a<00:02:18.450> to

00:02:18.559 --> 00:02:18.569 
wider than intz so python converts a to

00:02:18.569 --> 00:02:22.100 
wider than intz so python converts a to
a<00:02:18.810> float<00:02:19.140> then<00:02:19.680> adds<00:02:19.980> the<00:02:20.390> result<00:02:21.390> is<00:02:21.540> 8<00:02:21.720> as<00:02:22.049> a

00:02:22.100 --> 00:02:22.110 
a float then adds the result is 8 as a

00:02:22.110 --> 00:02:26.930 
a float then adds the result is 8 as a
float<00:02:22.650> not<00:02:23.130> 8<00:02:23.370> as<00:02:23.700> an<00:02:23.819> INT<00:02:24.739> subtraction<00:02:25.739> if<00:02:25.940> we

00:02:26.930 --> 00:02:26.940 
float not 8 as an INT subtraction if we

00:02:26.940 --> 00:02:29.660 
float not 8 as an INT subtraction if we
compute<00:02:27.299> B<00:02:27.569> minus<00:02:27.959> a<00:02:28.079> we<00:02:28.769> are<00:02:28.890> subtracting<00:02:29.519> an

00:02:29.660 --> 00:02:29.670 
compute B minus a we are subtracting an

00:02:29.670 --> 00:02:32.390 
compute B minus a we are subtracting an
INT<00:02:29.849> from<00:02:30.269> a<00:02:30.360> float<00:02:30.799> InSAR<00:02:31.799> narrower<00:02:32.130> than

00:02:32.390 --> 00:02:32.400 
INT from a float InSAR narrower than

00:02:32.400 --> 00:02:34.970 
INT from a float InSAR narrower than
floats<00:02:32.700> so<00:02:32.910> python<00:02:33.720> widens<00:02:34.230> a<00:02:34.440> to<00:02:34.500> a<00:02:34.680> float

00:02:34.970 --> 00:02:34.980 
floats so python widens a to a float

00:02:34.980 --> 00:02:38.870 
floats so python widens a to a float
then<00:02:35.549> subtracts<00:02:36.209> the<00:02:36.930> result<00:02:37.260> is<00:02:37.380> 4.0<00:02:38.220> which

00:02:38.870 --> 00:02:38.880 
then subtracts the result is 4.0 which

00:02:38.880 --> 00:02:42.979 
then subtracts the result is 4.0 which
is<00:02:39.030> a<00:02:39.060> float<00:02:40.370> multiplication<00:02:41.370> if<00:02:41.540> we<00:02:42.540> multiply

00:02:42.979 --> 00:02:42.989 
is a float multiplication if we multiply

00:02:42.989 --> 00:02:46.699 
is a float multiplication if we multiply
a<00:02:43.170> and<00:02:43.530> 7<00:02:44.010> we<00:02:44.489> are<00:02:44.519> multiplying<00:02:45.090> 2<00:02:45.360> in<00:02:45.709> no

00:02:46.699 --> 00:02:46.709 
a and 7 we are multiplying 2 in no

00:02:46.709 --> 00:02:48.680 
a and 7 we are multiplying 2 in no
widening<00:02:47.220> is<00:02:47.340> required<00:02:47.760> and<00:02:47.970> the<00:02:48.209> result<00:02:48.540> is

00:02:48.680 --> 00:02:48.690 
widening is required and the result is

00:02:48.690 --> 00:02:54.530 
widening is required and the result is
14<00:02:50.120> division<00:02:51.120> divide<00:02:51.959> C<00:02:52.260> by<00:02:52.470> B<00:02:53.359> floats<00:02:54.359> are

00:02:54.530 --> 00:02:54.540 
14 division divide C by B floats are

00:02:54.540 --> 00:02:56.720 
14 division divide C by B floats are
narrower<00:02:54.870> than<00:02:55.079> complex<00:02:55.530> numbers<00:02:55.889> so<00:02:56.400> B<00:02:56.579> is

00:02:56.720 --> 00:02:56.730 
narrower than complex numbers so B is

00:02:56.730 --> 00:02:58.699 
narrower than complex numbers so B is
widened<00:02:57.239> to<00:02:57.299> a<00:02:57.389> complex<00:02:57.780> number<00:02:57.930> before<00:02:58.530> the

00:02:58.699 --> 00:02:58.709 
widened to a complex number before the

00:02:58.709 --> 00:03:02.960 
widened to a complex number before the
division<00:02:59.000> we<00:03:00.000> get<00:03:00.269> 2<00:03:00.510> plus<00:03:00.870> 0j<00:03:01.549> while<00:03:02.549> this<00:03:02.790> is

00:03:02.960 --> 00:03:02.970 
division we get 2 plus 0j while this is

00:03:02.970 --> 00:03:05.569 
division we get 2 plus 0j while this is
the<00:03:03.090> same<00:03:03.359> as<00:03:03.569> the<00:03:03.690> integer<00:03:04.049> to<00:03:04.319> Python<00:03:05.220> stores

00:03:05.569 --> 00:03:05.579 
the same as the integer to Python stores

00:03:05.579 --> 00:03:07.879 
the same as the integer to Python stores
it<00:03:05.730> as<00:03:05.819> a<00:03:05.850> complex<00:03:06.269> number<00:03:06.510> you<00:03:07.470> can<00:03:07.680> tell

00:03:07.879 --> 00:03:07.889 
it as a complex number you can tell

00:03:07.889 --> 00:03:10.610 
it as a complex number you can tell
because<00:03:08.100> it<00:03:08.340> has<00:03:08.489> an<00:03:08.639> imaginary<00:03:09.090> part<00:03:09.620> don't

00:03:10.610 --> 00:03:10.620 
because it has an imaginary part don't

00:03:10.620 --> 00:03:12.680 
because it has an imaginary part don't
forget<00:03:10.980> that<00:03:11.160> Python<00:03:11.549> uses<00:03:11.880> J<00:03:12.150> is<00:03:12.299> the<00:03:12.420> square

00:03:12.680 --> 00:03:12.690 
forget that Python uses J is the square

00:03:12.690 --> 00:03:16.010 
forget that Python uses J is the square
root<00:03:12.720> of<00:03:12.870> negative<00:03:13.230> 1<00:03:13.650> not<00:03:14.130> I

00:03:16.010 --> 00:03:16.020 
root of negative 1 not I

00:03:16.020 --> 00:03:18.170 
root of negative 1 not I
recall<00:03:16.920> that<00:03:17.100> when<00:03:17.250> you<00:03:17.310> divide<00:03:17.580> one<00:03:18.000> number

00:03:18.170 --> 00:03:18.180 
recall that when you divide one number

00:03:18.180 --> 00:03:20.480 
recall that when you divide one number
by<00:03:18.450> another<00:03:18.750> using<00:03:18.990> long<00:03:19.320> division<00:03:19.350> you<00:03:20.010> get

00:03:20.480 --> 00:03:20.490 
by another using long division you get

00:03:20.490 --> 00:03:22.790 
by another using long division you get
two<00:03:20.700> numbers<00:03:21.120> a<00:03:21.330> quotient<00:03:21.900> and<00:03:22.200> a<00:03:22.440> remainder

00:03:22.790 --> 00:03:22.800 
two numbers a quotient and a remainder

00:03:22.800 --> 00:03:25.190 
two numbers a quotient and a remainder
in<00:03:23.390> Python<00:03:24.390> version<00:03:24.420> two

00:03:25.190 --> 00:03:25.200 
in Python version two

00:03:25.200 --> 00:03:27.170 
in Python version two
dividing<00:03:25.860> two<00:03:26.040> whole<00:03:26.250> numbers<00:03:26.640> would<00:03:26.910> return

00:03:27.170 --> 00:03:27.180 
dividing two whole numbers would return

00:03:27.180 --> 00:03:29.990 
dividing two whole numbers would return
the<00:03:27.240> quotient<00:03:27.750> not<00:03:28.230> the<00:03:28.380> actual<00:03:28.770> value<00:03:29.130> this

00:03:29.990 --> 00:03:30.000 
the quotient not the actual value this

00:03:30.000 --> 00:03:33.110 
the quotient not the actual value this
has<00:03:30.180> been<00:03:30.360> changed<00:03:30.780> in<00:03:30.930> Python<00:03:31.320> 3<00:03:31.700> now<00:03:32.700> if<00:03:32.730> you

00:03:33.110 --> 00:03:33.120 
has been changed in Python 3 now if you

00:03:33.120 --> 00:03:35.150 
has been changed in Python 3 now if you
divide<00:03:33.390> two<00:03:33.420> whole<00:03:33.780> numbers<00:03:33.960> the<00:03:34.380> result<00:03:34.740> is<00:03:35.100> a

00:03:35.150 --> 00:03:35.160 
divide two whole numbers the result is a

00:03:35.160 --> 00:03:37.970 
divide two whole numbers the result is a
float<00:03:35.840> even<00:03:36.840> if<00:03:36.930> there<00:03:37.080> is<00:03:37.200> no<00:03:37.350> remainder<00:03:37.830> the

00:03:37.970 --> 00:03:37.980 
float even if there is no remainder the

00:03:37.980 --> 00:03:40.460 
float even if there is no remainder the
value<00:03:38.280> is<00:03:38.430> still<00:03:38.640> a<00:03:38.670> float<00:03:39.050> the<00:03:40.050> percent

00:03:40.460 --> 00:03:40.470 
value is still a float the percent

00:03:40.470 --> 00:03:42.260 
value is still a float the percent
operator<00:03:40.920> returns<00:03:41.550> the<00:03:41.640> remainder<00:03:42.060> of<00:03:42.090> the

00:03:42.260 --> 00:03:42.270 
operator returns the remainder of the

00:03:42.270 --> 00:03:44.600 
operator returns the remainder of the
long<00:03:42.420> division<00:03:42.720> and<00:03:43.250> if<00:03:44.250> you<00:03:44.340> want<00:03:44.520> the

00:03:44.600 --> 00:03:44.610 
long division and if you want the

00:03:44.610 --> 00:03:46.400 
long division and if you want the
quotient<00:03:45.030> you<00:03:45.420> use<00:03:45.630> a<00:03:45.660> double<00:03:45.900> division

00:03:46.400 --> 00:03:46.410 
quotient you use a double division

00:03:46.410 --> 00:03:49.550 
quotient you use a double division
symbol<00:03:47.330> don't<00:03:48.330> forget<00:03:48.630> the<00:03:48.750> big<00:03:48.900> exception<00:03:49.440> in

00:03:49.550 --> 00:03:49.560 
symbol don't forget the big exception in

00:03:49.560 --> 00:03:52.220 
symbol don't forget the big exception in
arithmetic<00:03:50.070> you<00:03:50.730> cannot<00:03:51.060> divide<00:03:51.480> by<00:03:51.690> 0<00:03:51.960> in

00:03:52.220 --> 00:03:52.230 
arithmetic you cannot divide by 0 in

00:03:52.230 --> 00:03:55.250 
arithmetic you cannot divide by 0 in
math<00:03:53.070> is<00:03:53.340> undefined<00:03:54.060> and<00:03:54.300> in<00:03:54.660> Python<00:03:55.080> it

00:03:55.250 --> 00:03:55.260 
math is undefined and in Python it

00:03:55.260 --> 00:03:57.920 
math is undefined and in Python it
throws<00:03:55.440> a<00:03:55.470> zero<00:03:55.770> division<00:03:56.070> error<00:03:56.540> be<00:03:57.540> careful

00:03:57.920 --> 00:03:57.930 
throws a zero division error be careful

00:03:57.930 --> 00:04:00.020 
throws a zero division error be careful
when<00:03:58.080> dividing<00:03:58.470> two<00:03:58.620> numbers<00:03:58.790> unless<00:03:59.790> you<00:03:59.940> are

00:04:00.020 --> 00:04:00.030 
when dividing two numbers unless you are

00:04:00.030 --> 00:04:01.940 
when dividing two numbers unless you are
certain<00:04:00.390> the<00:04:00.510> denominator<00:04:01.020> is<00:04:01.170> not<00:04:01.320> 0<00:04:01.680> you

00:04:01.940 --> 00:04:01.950 
certain the denominator is not 0 you

00:04:01.950 --> 00:04:03.530 
certain the denominator is not 0 you
will<00:04:02.460> have<00:04:02.640> to<00:04:02.760> be<00:04:02.850> prepared<00:04:03.240> for<00:04:03.300> this

00:04:03.530 --> 00:04:03.540 
will have to be prepared for this

00:04:03.540 --> 00:04:08.840 
will have to be prepared for this
possibility<00:04:06.830> when<00:04:07.830> combining<00:04:08.220> two<00:04:08.490> numbers

00:04:08.840 --> 00:04:08.850 
possibility when combining two numbers

00:04:08.850 --> 00:04:10.370 
possibility when combining two numbers
using<00:04:09.090> addition<00:04:09.600> subtraction

00:04:10.370 --> 00:04:10.380 
using addition subtraction

00:04:10.380 --> 00:04:12.710 
using addition subtraction
multiplication<00:04:10.500> or<00:04:11.250> division<00:04:11.540> Python<00:04:12.540> will

00:04:12.710 --> 00:04:12.720 
multiplication or division Python will

00:04:12.720 --> 00:04:14.270 
multiplication or division Python will
widen<00:04:13.080> any<00:04:13.230> numbers<00:04:13.620> to<00:04:13.830> make<00:04:13.950> sure<00:04:14.070> all

00:04:14.270 --> 00:04:14.280 
widen any numbers to make sure all

00:04:14.280 --> 00:04:16.120 
widen any numbers to make sure all
values<00:04:14.760> are<00:04:14.940> of<00:04:15.180> the<00:04:15.270> same<00:04:15.480> type

00:04:16.120 --> 00:04:16.130 
values are of the same type

00:04:16.130 --> 00:04:19.370 
values are of the same type
unlike<00:04:17.130> Python<00:04:17.520> 2<00:04:17.790> division<00:04:18.660> in<00:04:18.750> Python<00:04:19.140> 3

00:04:19.370 --> 00:04:19.380 
unlike Python 2 division in Python 3

00:04:19.380 --> 00:04:21.260 
unlike Python 2 division in Python 3
returns<00:04:19.739> the<00:04:19.860> correct<00:04:20.100> math<00:04:20.370> value<00:04:20.820> as<00:04:21.210> a

00:04:21.260 --> 00:04:21.270 
returns the correct math value as a

00:04:21.270 --> 00:04:23.960 
returns the correct math value as a
float<00:04:21.660> or<00:04:21.900> complex<00:04:22.530> number<00:04:22.860> it<00:04:23.490> does<00:04:23.820> not

00:04:23.960 --> 00:04:23.970 
float or complex number it does not

00:04:23.970 --> 00:04:26.210 
float or complex number it does not
return<00:04:24.210> the<00:04:24.420> quotient<00:04:24.840> and<00:04:25.050> don't<00:04:25.980> forget

00:04:26.210 --> 00:04:26.220 
return the quotient and don't forget

00:04:26.220 --> 00:04:29.720 
return the quotient and don't forget
what<00:04:26.370> happens<00:04:26.760> when<00:04:26.940> you<00:04:27.030> divide<00:04:27.150> by<00:04:27.450> 0

