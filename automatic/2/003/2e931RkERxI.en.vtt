WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.230
 hello welcome to my landmark channel in this 

00:00:02.370 --> 00:00:06.299
 opportunity I will create a section that 

00:00:04.230 --> 00:00:08.069
 it's called recursion in weeks in 

00:00:06.299 --> 00:00:09.990
 where I'm going to explain exercises 

00:00:08.069 --> 00:00:11.969
 facts with recursion to start 

00:00:09.990 --> 00:00:13.980
 this first video I'm going to make a 

00:00:11.969 --> 00:00:16.410
 exercise that is to convert a number 

00:00:13.980 --> 00:00:18.150
 natural to binary recursively 

00:00:16.410 --> 00:00:22.619
 for this case we are going to create a new 

00:00:18.150 --> 00:00:25.109
 file what we will call binary and how 

00:00:22.619 --> 00:00:30.750
 typical way we will always start with the 

00:00:25.109 --> 00:00:32.759
 club and strain and if you do not see me stv and 

00:00:30.750 --> 00:00:35.579
 then go to the main function and 

00:00:32.759 --> 00:00:37.620
 return to zero to begin with we declare 

00:00:35.579 --> 00:00:39.149
 a variable and cn that the command the 

00:00:37.620 --> 00:00:40.590
 number that we are going to convert to binary 

00:00:39.149 --> 00:00:42.420
 then we have to validate that this 

00:00:40.590 --> 00:00:44.610
 number he found out because if he did not find out 

00:00:42.420 --> 00:00:47.190
 we will have problems because of this we created a 

00:00:44.610 --> 00:00:48.899
 Uruguay while the number n is lower 

00:00:47.190 --> 00:00:51.350
 that zero as long as it is less than zero 

00:00:48.899 --> 00:00:53.960
 ask enter the number iv 

00:00:51.350 --> 00:00:56.269
 then it will store it in variable n 

00:00:53.960 --> 00:00:59.149
 then if the number is smaller 

00:00:56.269 --> 00:01:02.510
 that zero has to show a message if 

00:00:59.149 --> 00:01:05.409
 n is less than zero you have to show me 

00:01:02.510 --> 00:01:05.409
 the message code 

00:01:06.800 --> 00:01:10.030
 an invalid number 

00:01:10.810 --> 00:01:14.310
 the number one 

00:01:14.790 --> 00:01:22.080
 and if not and if it is not this minor 

00:01:18.900 --> 00:01:25.710
 will continue with the program and not keep 

00:01:22.080 --> 00:01:28.200
 This message was followed by the 

00:01:25.710 --> 00:01:29.220
 number that is greater than 0 in this case 

00:01:28.200 --> 00:01:31.560
 once it is greater than zero 

00:01:29.220 --> 00:01:35.340
 you just have to show the number 

00:01:31.560 --> 00:01:37.620
 with number and we will show it and then 

00:01:35.340 --> 00:01:39.450
 let's show its binary form but 

00:01:37.620 --> 00:01:41.610
 using recursion but first that 

00:01:39.450 --> 00:01:43.979
 we put a line that would be the code in 

00:01:41.610 --> 00:01:46.410
 binary interior of binary form and 

00:01:43.979 --> 00:01:48.390
 let's call the urinary function 

00:01:46.410 --> 00:01:49.950
 let's create a binary function the 

00:01:48.390 --> 00:01:52.080
 which will be responsible for doing so 

00:01:49.950 --> 00:01:54.000
 recursive for this binary case there 

00:01:52.080 --> 00:01:57.360
 returns nothing in this case would be boy 

00:01:54.000 --> 00:02:00.630
 binary as parameters enter a 

00:01:57.360 --> 00:02:02.790
 integer type n and here the function 

00:02:00.630 --> 00:02:05.280
 of simple recontra binary you only go to 

00:02:02.790 --> 00:02:07.590
 analyze a bit then what could we 

00:02:05.280 --> 00:02:09.450
 do so that our whole number will 

00:02:07.590 --> 00:02:12.090
 has turned a form into binary 

00:02:09.450 --> 00:02:13.950
 simple would be to divide it between two and 

00:02:12.090 --> 00:02:17.190
 remove the module as it is done 

00:02:13.950 --> 00:02:19.620
 normal but the module would be shown in 

00:02:17.190 --> 00:02:20.940
 this case would simply be worth composing 

00:02:19.620 --> 00:02:24.360
 a base house condition 

00:02:20.940 --> 00:02:25.890
 what would it be if the number is greater than 1 if 

00:02:24.360 --> 00:02:28.500
 is that number is greater than 1 then 

00:02:25.890 --> 00:02:32.370
 what is going to be going to call binary 

00:02:28.500 --> 00:02:33.870
 recursive form n divided by 2 that 

00:02:32.370 --> 00:02:36.090
 would be the condition is that the number of 

00:02:33.870 --> 00:02:38.670
 greater than one is going to call binary 

00:02:36.090 --> 00:02:41.490
 between 2 to the number between 2 and if it were not 

00:02:38.670 --> 00:02:44.550
 the case then just simply 

00:02:41.490 --> 00:02:46.650
 would show the number module that 

00:02:44.550 --> 00:02:48.660
 we have in this case in module 2 

00:02:46.650 --> 00:02:50.610
 then here I will explain a bit how 

00:02:48.660 --> 00:02:52.170
 It would be here, above, I will comment 

00:02:50.610 --> 00:02:56.250
 so what would happen if the number 

00:02:52.170 --> 00:02:57.210
 entered would be 12 when entering this in 

00:02:56.250 --> 00:02:59.610
 this function 

00:02:57.210 --> 00:03:02.310
 simply ask if 12 is greater than 

00:02:59.610 --> 00:03:04.470
 1 then thing that if it is greater then 

00:03:02.310 --> 00:03:09.360
 call the binary function between 2 

00:03:04.470 --> 00:03:11.760
 then I would call 6 on that day 6 6 is 

00:03:09.360 --> 00:03:14.730
 greater than 1 if then it would be called in 

00:03:11.760 --> 00:03:17.250
 module 2 that would be 3 3 is the biggest 

00:03:14.730 --> 00:03:20.430
 that 1 if then I would call the function 

00:03:17.250 --> 00:03:22.290
 binary n between 2 that would be how it is 

00:03:20.430 --> 00:03:24.959
 the floating ones are not counted 

00:03:22.290 --> 00:03:25.530
 would return to 1 then in the greater than 

00:03:24.959 --> 00:03:28.770
 one 

00:03:25.530 --> 00:03:30.450
 then simply print and 

00:03:28.770 --> 00:03:33.959
 writing the biggest one prints in 

00:03:30.450 --> 00:03:37.140
 the modules as the one module is one 

00:03:33.959 --> 00:03:39.390
 then print one then return the 

00:03:37.140 --> 00:03:41.850
 recursive function to three and then print 

00:03:39.390 --> 00:03:42.600
 a module three module forgiveness in the 

00:03:41.850 --> 00:03:45.239
 module 2 

00:03:42.600 --> 00:03:49.200
 then in module 2 that is 3 would be 

00:03:45.239 --> 00:03:52.110
 the module of 3 is the remainder would be 1 

00:03:49.200 --> 00:03:55.110
 then it returns and goes to 6 it would be equal to 

00:03:52.110 --> 00:03:58.100
 0 and he would return the module function 

00:03:55.110 --> 00:04:01.830
 12 would be 0 in this case as we see 

00:03:58.100 --> 00:04:03.480
 just print to 1100 that is a 

00:04:01.830 --> 00:04:05.580
 binary number 

00:04:03.480 --> 00:04:07.470
 as we see in this case it will print the 

00:04:05.580 --> 00:04:10.980
 binary number starting from a 

00:04:07.470 --> 00:04:13.830
 term by 0 that would be 1100 and as 

00:04:10.980 --> 00:04:15.269
 this is true we can see that it meets 

00:04:13.830 --> 00:04:16.560
 all the features we 

00:04:15.269 --> 00:04:19.979
 we tested the program 

00:04:16.560 --> 00:04:22.109
 enter the number 12 the number 12 and the 

00:04:19.979 --> 00:04:24.180
 binary 1100 as we can see and if 

00:04:22.109 --> 00:04:25.410
 we try with any number if it goes 

00:04:24.180 --> 00:04:28.560
 to give the result for example if 

00:04:25.410 --> 00:04:30.630
 entered the number 15 would be 41 then 

00:04:28.560 --> 00:04:32.729
 the number 15 the ordinary result 

00:04:30.630 --> 00:04:34.410
 it would be 41 as we could see these are 

00:04:32.729 --> 00:04:36.570
 simple recursive exercises 

00:04:34.410 --> 00:04:40.340
 subscribe to my channel and keep receiving 

00:04:36.570 --> 00:04:40.340
 more videos of this type 

