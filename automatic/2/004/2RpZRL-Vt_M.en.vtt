WEBVTT
Kind: captions
Language: en

00:00:06.140 --> 00:00:08.750 

collision<00:00:07.140> detection<00:00:07.470> is<00:00:07.800> a<00:00:07.860> major<00:00:08.190> challenge

00:00:08.750 --> 00:00:08.760 
collision detection is a major challenge

00:00:08.760 --> 00:00:11.299 
collision detection is a major challenge
in<00:00:08.970> simulating<00:00:09.630> deformable<00:00:10.230> models<00:00:10.650> it<00:00:11.010> can

00:00:11.299 --> 00:00:11.309 
in simulating deformable models it can

00:00:11.309 --> 00:00:19.710 
in simulating deformable models it can
take<00:00:11.549> up<00:00:11.700> to<00:00:11.820> 90%<00:00:12.629> of<00:00:12.809> simulation<00:00:13.469> time

00:00:19.710 --> 00:00:19.720 

00:00:19.720 --> 00:00:22.810 

one<00:00:20.720> of<00:00:20.840> the<00:00:20.960> major<00:00:21.200> challenges<00:00:21.590> lies<00:00:22.310> in<00:00:22.580> self

00:00:22.810 --> 00:00:22.820 
one of the major challenges lies in self

00:00:22.820 --> 00:00:25.660 
one of the major challenges lies in self
collision<00:00:23.300> detection<00:00:23.630> in<00:00:24.020> this<00:00:24.710> scene<00:00:25.010> we<00:00:25.490> see

00:00:25.660 --> 00:00:25.670 
collision detection in this scene we see

00:00:25.670 --> 00:00:30.620 
collision detection in this scene we see
the<00:00:25.790> skirt<00:00:26.060> collide<00:00:26.510> with<00:00:26.840> itself

00:00:30.620 --> 00:00:30.630 

00:00:30.630 --> 00:00:33.510 

we<00:00:31.630> decompose<00:00:32.230> the<00:00:32.410> problem<00:00:32.439> into<00:00:32.890> checking

00:00:33.510 --> 00:00:33.520 
we decompose the problem into checking

00:00:33.520 --> 00:00:35.790 
we decompose the problem into checking
for<00:00:33.700> possible<00:00:34.120> interference<00:00:34.420> among<00:00:34.989> adjacent

00:00:35.790 --> 00:00:35.800 
for possible interference among adjacent

00:00:35.800 --> 00:00:38.520 
for possible interference among adjacent
primitives<00:00:36.309> as<00:00:36.520> shown<00:00:36.850> on<00:00:36.880> the<00:00:37.180> left<00:00:37.450> and<00:00:37.780> non

00:00:38.520 --> 00:00:38.530 
primitives as shown on the left and non

00:00:38.530 --> 00:00:40.650 
primitives as shown on the left and non
adjacent<00:00:38.710> primitives<00:00:39.579> in<00:00:39.760> the<00:00:39.850> mesh<00:00:40.059> as<00:00:40.329> shown

00:00:40.650 --> 00:00:40.660 
adjacent primitives in the mesh as shown

00:00:40.660 --> 00:00:43.630 
adjacent primitives in the mesh as shown
on<00:00:40.840> the<00:00:40.989> right

00:00:43.630 --> 00:00:43.640 

00:00:43.640 --> 00:00:46.450 

we<00:00:44.450> compute<00:00:44.960> a<00:00:45.080> chromatic<00:00:45.590> decomposition<00:00:46.340> of

00:00:46.450 --> 00:00:46.460 
we compute a chromatic decomposition of

00:00:46.460 --> 00:00:49.300 
we compute a chromatic decomposition of
a<00:00:46.550> mesh<00:00:46.820> to<00:00:47.750> illustrate<00:00:48.260> the<00:00:48.380> concept<00:00:48.890> we<00:00:49.130> show

00:00:49.300 --> 00:00:49.310 
a mesh to illustrate the concept we show

00:00:49.310 --> 00:00:52.650 
a mesh to illustrate the concept we show
a<00:00:49.340> simple<00:00:49.820> example

00:00:52.650 --> 00:00:52.660 

00:00:52.660 --> 00:00:55.530 

as<00:00:52.770> shown<00:00:53.770> here<00:00:53.829> we<00:00:54.520> make<00:00:54.730> sure<00:00:54.970> that<00:00:55.000> every

00:00:55.530 --> 00:00:55.540 
as shown here we make sure that every

00:00:55.540 --> 00:00:57.479 
as shown here we make sure that every
neighboring<00:00:56.050> polygon<00:00:56.560> of<00:00:56.770> the<00:00:57.010> polygon

00:00:57.479 --> 00:00:57.489 
neighboring polygon of the polygon

00:00:57.489 --> 00:01:03.250 
neighboring polygon of the polygon
highlighted<00:00:58.060> in<00:00:58.180> red<00:00:58.210> has<00:00:58.989> a<00:00:59.020> different<00:00:59.440> color

00:01:03.250 --> 00:01:03.260 

00:01:03.260 --> 00:01:06.080 

next<00:01:04.260> we<00:01:04.410> make<00:01:04.559> sure<00:01:04.800> that<00:01:05.040> every<00:01:05.309> polygon<00:01:05.760> at

00:01:06.080 --> 00:01:06.090 
next we make sure that every polygon at

00:01:06.090 --> 00:01:08.570 
next we make sure that every polygon at
distance<00:01:06.540> of<00:01:06.690> two<00:01:07.020> in<00:01:07.290> the<00:01:07.350> mesh<00:01:07.710> also<00:01:08.340> has<00:01:08.550> a

00:01:08.570 --> 00:01:08.580 
distance of two in the mesh also has a

00:01:08.580 --> 00:01:11.590 
distance of two in the mesh also has a
different<00:01:08.970> color

00:01:11.590 --> 00:01:11.600 

00:01:11.600 --> 00:01:14.230 

here<00:01:12.409> we<00:01:12.590> show<00:01:12.799> the<00:01:12.979> chromatic<00:01:13.430> decomposition

00:01:14.230 --> 00:01:14.240 
here we show the chromatic decomposition

00:01:14.240 --> 00:01:18.370 
here we show the chromatic decomposition
of<00:01:14.420> a<00:01:14.630> triangulated<00:01:15.259> mesh<00:01:15.640> in<00:01:17.380> this

00:01:18.370 --> 00:01:18.380 
of a triangulated mesh in this

00:01:18.380 --> 00:01:20.230 
of a triangulated mesh in this
split-screen<00:01:18.860> video<00:01:19.369> we<00:01:19.850> highlight<00:01:20.210> the

00:01:20.230 --> 00:01:20.240 
split-screen video we highlight the

00:01:20.240 --> 00:01:23.920 
split-screen video we highlight the
benefits<00:01:20.840> of<00:01:21.020> 2.5<00:01:21.860> D<00:01:22.159> overlap<00:01:22.670> tests<00:01:23.180> on<00:01:23.299> the

00:01:23.920 --> 00:01:23.930 
benefits of 2.5 D overlap tests on the

00:01:23.930 --> 00:01:26.590 
benefits of 2.5 D overlap tests on the
Left<00:01:24.170> we<00:01:24.409> show<00:01:24.619> the<00:01:24.740> pcs<00:01:25.340> in<00:01:25.610> orange<00:01:26.030> obtained

00:01:26.590 --> 00:01:26.600 
Left we show the pcs in orange obtained

00:01:26.600 --> 00:01:31.270 
Left we show the pcs in orange obtained
using<00:01:26.930> an<00:01:27.229> AABB<00:01:28.220> hierarchy<00:01:29.000> on<00:01:29.619> the<00:01:30.619> right<00:01:30.860> we

00:01:31.270 --> 00:01:31.280 
using an AABB hierarchy on the right we

00:01:31.280 --> 00:01:33.010 
using an AABB hierarchy on the right we
highlight<00:01:31.640> the<00:01:31.670> PCs<00:01:32.299> and<00:01:32.479> orange<00:01:32.840> after

00:01:33.010 --> 00:01:33.020 
highlight the PCs and orange after

00:01:33.020 --> 00:01:38.740 
highlight the PCs and orange after
performing<00:01:33.830> 2.5<00:01:34.580> do<00:01:34.940> overlap<00:01:35.270> tests<00:01:37.630> we<00:01:38.630> have

00:01:38.740 --> 00:01:38.750 
performing 2.5 do overlap tests we have

00:01:38.750 --> 00:01:40.960 
performing 2.5 do overlap tests we have
implemented<00:01:39.200> our<00:01:39.470> algorithm<00:01:40.130> and<00:01:40.340> tested<00:01:40.850> it

00:01:40.960 --> 00:01:40.970 
implemented our algorithm and tested it

00:01:40.970 --> 00:01:44.109 
implemented our algorithm and tested it
on<00:01:41.149> a<00:01:41.210> high-end<00:01:41.630> PC<00:01:42.470> with<00:01:42.740> a<00:01:42.770> 3.4<00:01:43.729> gigahertz

00:01:44.109 --> 00:01:44.119 
on a high-end PC with a 3.4 gigahertz

00:01:44.119 --> 00:01:47.859 
on a high-end PC with a 3.4 gigahertz
Pentium<00:01:44.899> 4<00:01:45.140> processor<00:01:45.770> and<00:01:46.009> an<00:01:46.520> Envy<00:01:46.880> 6800

00:01:47.859 --> 00:01:47.869 
Pentium 4 processor and an Envy 6800

00:01:47.869 --> 00:01:54.230 
Pentium 4 processor and an Envy 6800
graphics<00:01:48.319> card

00:01:54.230 --> 00:01:54.240 

00:01:54.240 --> 00:01:57.289 

in<00:01:54.299> this<00:01:55.229> example<00:01:55.680> each<00:01:56.040> step<00:01:56.729> takes<00:01:57.149> about

00:01:57.289 --> 00:01:57.299 
in this example each step takes about

00:01:57.299 --> 00:02:00.590 
in this example each step takes about
100<00:01:57.930> to<00:01:58.140> 150<00:01:58.799> milliseconds<00:01:59.729> to<00:02:00.240> perform

00:02:00.590 --> 00:02:00.600 
100 to 150 milliseconds to perform

00:02:00.600 --> 00:02:02.359 
100 to 150 milliseconds to perform
collision<00:02:01.049> detection<00:02:01.380> for<00:02:01.829> the<00:02:01.920> opening

00:02:02.359 --> 00:02:02.369 
collision detection for the opening

00:02:02.369 --> 00:02:09.490 
collision detection for the opening
curtains

00:02:09.490 --> 00:02:09.500 

00:02:09.500 --> 00:02:12.870 

you

00:02:12.870 --> 00:02:12.880 

00:02:12.880 --> 00:02:15.640 

we<00:02:13.880> have<00:02:14.030> also<00:02:14.210> integrated<00:02:15.050> our<00:02:15.170> collision

00:02:15.640 --> 00:02:15.650 
we have also integrated our collision

00:02:15.650 --> 00:02:17.680 
we have also integrated our collision
detection<00:02:15.980> algorithm<00:02:16.730> with<00:02:17.060> a<00:02:17.090> surgical

00:02:17.680 --> 00:02:17.690 
detection algorithm with a surgical

00:02:17.690 --> 00:02:19.720 
detection algorithm with a surgical
planning<00:02:17.990> method<00:02:18.470> for<00:02:19.010> inserting<00:02:19.370> a<00:02:19.550> catheter

00:02:19.720 --> 00:02:19.730 
planning method for inserting a catheter

00:02:19.730 --> 00:02:22.180 
planning method for inserting a catheter
into<00:02:20.240> the<00:02:20.390> liver<00:02:20.690> arteries<00:02:21.260> for<00:02:21.740> delivering

00:02:22.180 --> 00:02:22.190 
into the liver arteries for delivering

00:02:22.190 --> 00:02:27.930 
into the liver arteries for delivering
medication<00:02:22.850> directly<00:02:23.450> to<00:02:23.630> a<00:02:23.660> tumor

00:02:27.930 --> 00:02:27.940 

00:02:27.940 --> 00:02:30.900 

the<00:02:28.780> catheter<00:02:29.200> is<00:02:29.320> a<00:02:29.530> deformable<00:02:30.160> tube-like

00:02:30.900 --> 00:02:30.910 
the catheter is a deformable tube-like

00:02:30.910 --> 00:02:33.590 
the catheter is a deformable tube-like
object<00:02:31.570> as<00:02:31.750> seen<00:02:32.110> in<00:02:32.140> this<00:02:32.380> video<00:02:32.710> segment<00:02:33.040> as

00:02:33.590 --> 00:02:33.600 
object as seen in this video segment as

00:02:33.600 --> 00:02:36.420 
object as seen in this video segment as
the<00:02:34.600> deforming<00:02:35.110> tube<00:02:35.410> is<00:02:35.620> inserted<00:02:36.130> into<00:02:36.310> the

00:02:36.420 --> 00:02:36.430 
the deforming tube is inserted into the

00:02:36.430 --> 00:02:38.640 
the deforming tube is inserted into the
arteries<00:02:36.940> of<00:02:37.090> the<00:02:37.120> liver<00:02:37.390> it<00:02:37.690> must<00:02:38.230> be<00:02:38.380> checked

00:02:38.640 --> 00:02:38.650 
arteries of the liver it must be checked

00:02:38.650 --> 00:02:40.560 
arteries of the liver it must be checked
for<00:02:38.800> self<00:02:39.040> collisions<00:02:39.610> and<00:02:39.820> with<00:02:40.090> the<00:02:40.210> nearby

00:02:40.560 --> 00:02:40.570 
for self collisions and with the nearby

00:02:40.570 --> 00:02:43.650 
for self collisions and with the nearby
blood<00:02:40.870> vessels<00:02:41.460> the<00:02:42.460> catheter<00:02:42.940> is<00:02:43.090> constantly

00:02:43.650 --> 00:02:43.660 
blood vessels the catheter is constantly

00:02:43.660 --> 00:02:45.960 
blood vessels the catheter is constantly
in<00:02:43.900> a<00:02:43.990> near<00:02:44.230> contact<00:02:44.800> parallel<00:02:45.370> proximity

00:02:45.960 --> 00:02:45.970 
in a near contact parallel proximity

00:02:45.970 --> 00:02:47.490 
in a near contact parallel proximity
situation<00:02:46.630> throughout<00:02:46.990> the<00:02:47.200> entire

00:02:47.490 --> 00:02:47.500 
situation throughout the entire

00:02:47.500 --> 00:02:50.900 
situation throughout the entire
simulation

00:02:50.900 --> 00:02:50.910 

00:02:50.910 --> 00:02:53.660 

our<00:02:51.590> algorithm<00:02:52.590> checks<00:02:52.920> for<00:02:53.160> all<00:02:53.310> collisions

00:02:53.660 --> 00:02:53.670 
our algorithm checks for all collisions

00:02:53.670 --> 00:02:57.400 
our algorithm checks for all collisions
at<00:02:54.090> roughly<00:02:54.660> 12<00:02:55.020> to<00:02:55.320> 18<00:02:55.770> frames<00:02:56.100> per<00:02:56.430> second

00:02:57.400 --> 00:02:57.410 
at roughly 12 to 18 frames per second

00:02:57.410 --> 00:03:00.050 
at roughly 12 to 18 frames per second
outperforming<00:02:58.410> previous<00:02:58.890> algorithms<00:02:59.520> by<00:02:59.910> at

00:03:00.050 --> 00:03:00.060 
outperforming previous algorithms by at

00:03:00.060 --> 00:03:06.750 
outperforming previous algorithms by at
least<00:03:00.240> one<00:03:00.720> order<00:03:01.080> of<00:03:01.110> magnitude

00:03:06.750 --> 00:03:06.760 

00:03:06.760 --> 00:03:09.809 

in<00:03:06.819> this<00:03:07.810> example<00:03:08.230> our<00:03:08.650> algorithm<00:03:09.310> checks<00:03:09.610> for

00:03:09.809 --> 00:03:09.819 
in this example our algorithm checks for

00:03:09.819 --> 00:03:12.750 
in this example our algorithm checks for
collisions<00:03:10.269> in<00:03:10.510> 400<00:03:11.230> to<00:03:11.379> 500<00:03:11.980> milliseconds

00:03:12.750 --> 00:03:12.760 
collisions in 400 to 500 milliseconds

00:03:12.760 --> 00:03:19.559 
collisions in 400 to 500 milliseconds
per<00:03:13.030> time<00:03:13.269> step

00:03:19.559 --> 00:03:19.569 

00:03:19.569 --> 00:03:22.110 

our<00:03:19.689> algorithm<00:03:20.680> is<00:03:21.069> able<00:03:21.430> to<00:03:21.579> achieve<00:03:21.700> at

00:03:22.110 --> 00:03:22.120 
our algorithm is able to achieve at

00:03:22.120 --> 00:03:24.449 
our algorithm is able to achieve at
least<00:03:22.150> one<00:03:22.689> order<00:03:23.110> of<00:03:23.140> magnitude<00:03:23.459> performance

00:03:24.449 --> 00:03:24.459 
least one order of magnitude performance

00:03:24.459 --> 00:03:32.770 
least one order of magnitude performance
improvement<00:03:25.060> over<00:03:25.659> prior<00:03:25.959> methods

00:03:32.770 --> 00:03:32.780 

00:03:32.780 --> 00:03:35.750 

here<00:03:33.780> we<00:03:34.050> demonstrate<00:03:34.650> our<00:03:34.680> algorithm<00:03:35.370> on<00:03:35.550> an

00:03:35.750 --> 00:03:35.760 
here we demonstrate our algorithm on an

00:03:35.760 --> 00:03:38.390 
here we demonstrate our algorithm on an
animation<00:03:36.240> of<00:03:36.570> a<00:03:36.750> folding<00:03:37.200> layered<00:03:37.590> skirt

00:03:38.390 --> 00:03:38.400 
animation of a folding layered skirt

00:03:38.400 --> 00:03:40.640 
animation of a folding layered skirt
there<00:03:39.360> are<00:03:39.510> many<00:03:39.720> wrinkles<00:03:40.050> and<00:03:40.440> folds

00:03:40.640 --> 00:03:40.650 
there are many wrinkles and folds

00:03:40.650 --> 00:03:42.950 
there are many wrinkles and folds
causing<00:03:41.490> the<00:03:41.580> skirt<00:03:41.850> to<00:03:42.030> self<00:03:42.270> collide<00:03:42.690> at

00:03:42.950 --> 00:03:42.960 
causing the skirt to self collide at

00:03:42.960 --> 00:03:45.920 
causing the skirt to self collide at
many<00:03:43.170> different<00:03:43.650> locations<00:03:44.010> our<00:03:44.930> algorithm

00:03:45.920 --> 00:03:45.930 
many different locations our algorithm

00:03:45.930 --> 00:03:48.830 
many different locations our algorithm
checks<00:03:46.230> for<00:03:46.440> collisions<00:03:46.890> in<00:03:47.160> 300<00:03:47.970> to<00:03:48.240> 500

00:03:48.830 --> 00:03:48.840 
checks for collisions in 300 to 500

00:03:48.840 --> 00:03:57.670 
checks for collisions in 300 to 500
milliseconds<00:03:49.590> per<00:03:49.740> time<00:03:50.220> step

00:03:57.670 --> 00:03:57.680 

00:03:57.680 --> 00:03:59.739 

you

