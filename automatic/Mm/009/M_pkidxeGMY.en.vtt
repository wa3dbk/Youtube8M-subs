WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.500
 For this topic I will explain how to pass in the input string 

00:00:05.500 --> 00:00:10.310
 Here is ···X···· 

00:00:10.310 --> 00:00:13.320
 And change the string according to some rules 

00:00:13.320 --> 00:00:14.990
 The rules are as follows: 

00:00:14.990 --> 00:00:18.370
 View the three characters in a string 

00:00:18.370 --> 00:00:20.370
 And according to the rules here 

00:00:20.370 --> 00:00:22.950
 Change the middle character 

00:00:22.950 --> 00:00:25.970
 Don't worry about these numbers for a while, I will explain later. 

00:00:25.970 --> 00:00:29.140
 For these three characters 

00:00:29.140 --> 00:00:31.140
 They are ···X 

00:00:31.140 --> 00:00:34.450
 ··X represents the middle element 

00:00:34.450 --> 00:00:36.450
 Change to X 

00:00:36.450 --> 00:00:38.840
 For the next string, the new string 

00:00:38.840 --> 00:00:40.840
 This position will be X 

00:00:40.840 --> 00:00:42.840
 Position before the position 

00:00:42.840 --> 00:00:44.840
 ··· 

00:00:44.840 --> 00:00:47.610
 ···become 

00:00:47.610 --> 00:00:49.120
 One in the middle 

00:00:49.120 --> 00:00:50.760
 For the characters on both sides 

00:00:50.760 --> 00:00:53.210
 We need to connect 

00:00:53.210 --> 00:00:55.960
 For this one here 

00:00:55.960 --> 00:00:57.600
 On the left is a 

00:00:57.600 --> 00:00:59.110
 On the right is a 

00:00:59.110 --> 00:01:01.110
 still is··· 

00:01:01.110 --> 00:01:03.600
 ··· means changing the middle character to 

00:01:03.600 --> 00:01:05.330
 One· 

00:01:05.330 --> 00:01:07.030
 carry on 

00:01:07.030 --> 00:01:11.100
 Then I want to fill it with ·X· 

00:01:11.100 --> 00:01:14.170
 ·X· means to change the middle element to X 

00:01:14.170 --> 00:01:18.270
 X·· 

00:01:18.270 --> 00:01:20.270
 Turn the middle element into X 

00:01:20.270 --> 00:01:21.940
 still is··· 

00:01:21.940 --> 00:01:23.740
 In the middle is 

00:01:23.740 --> 00:01:26.390
 ··· The middle is 

00:01:26.390 --> 00:01:28.650
 ·· 

00:01:28.650 --> 00:01:31.270
 The last one is this first point 

00:01:31.270 --> 00:01:34.180
 ··· still is· 

00:01:34.180 --> 00:01:37.790
 The string was first changed 

00:01:37.790 --> 00:01:39.790
 We need to repeat it again 

00:01:39.790 --> 00:01:42.600
 This is the first generation 

00:01:42.600 --> 00:01:44.600
 This is the second generation 

00:01:44.600 --> 00:01:48.230
 Usually we will start from the beginning of the string 

00:01:48.230 --> 00:01:51.310
 But here is just to show better operation in the middle 

00:01:51.310 --> 00:01:54.360
 This time we will start at the beginning of the string 

00:01:54.360 --> 00:01:57.010
 Look at the above line 

00:01:57.010 --> 00:02:00.520
 First element 

00:02:00.520 --> 00:02:03.270
 On the left is a 

00:02:03.270 --> 00:02:05.950
 The right side is a. So it is... 

00:02:05.950 --> 00:02:07.650
 The result is· 

00:02:07.650 --> 00:02:09.650
 It is now ··X 

00:02:09.650 --> 00:02:12.890
 ··X is the number 2 here 

00:02:12.890 --> 00:02:14.890
 Draw X 

00:02:14.890 --> 00:02:17.350
 ·XX is X 

00:02:17.350 --> 00:02:20.070
 XXX is · 

00:02:20.070 --> 00:02:24.030
 XX· Yes· 

00:02:24.030 --> 00:02:28.200
 X·· is X 

00:02:28.200 --> 00:02:31.200
 ··· Yes· 

00:02:31.200 --> 00:02:34.770
 ··· still is· 

00:02:34.770 --> 00:02:37.050
 continue 

00:02:37.050 --> 00:02:41.020
 After five changes 

00:02:41.020 --> 00:02:45.210
 Get the string ···XX·XX 

00:02:45.210 --> 00:02:47.890
 It can be seen that there are interesting rules 

00:02:47.890 --> 00:02:51.920
 We can follow the second line 

00:02:51.920 --> 00:02:54.300
 · and X options in blue 

00:02:54.300 --> 00:02:56.300
 Perform many operations 

00:02:56.300 --> 00:02:59.830
 There can actually be 256 different ways 

00:02:59.830 --> 00:03:03.540
 In order to determine which pattern we will use 

00:03:03.540 --> 00:03:06.140
 Which rule 

00:03:06.140 --> 00:03:08.550
 We can number these rules 

00:03:08.550 --> 00:03:11.880
 As long as there is an X at the bottom 

00:03:11.880 --> 00:03:13.620
 I will add these numbers together. 

00:03:13.620 --> 00:03:18.190
 Ie 2 + 4 + 8 + 16 

00:03:18.190 --> 00:03:20.190
 The result is 30 

00:03:20.190 --> 00:03:24.710
 So here is the pattern 30 

00:03:24.710 --> 00:03:28.360
 We can choose a different pattern instead of pattern 30 

00:03:28.360 --> 00:03:31.740
 Suppose you choose pattern 69 

00:03:31.740 --> 00:03:35.040
 69 is equal. . . 

00:03:35.040 --> 00:03:37.690
 We need to look at the numbers above 

00:03:37.690 --> 00:03:40.380
 Think about which numbers are added 

00:03:40.380 --> 00:03:42.260
 Equal to 69 

00:03:42.260 --> 00:03:46.280
 Plus 128 is definitely not equal to 69, so no need for these 

00:03:46.280 --> 00:03:49.370
 64 can be written on 64 

00:03:49.370 --> 00:03:51.510
 No need for 32 

00:03:51.510 --> 00:03:54.200
 No need for 16 or 8 

00:03:54.200 --> 00:03:56.020
 But need 4 

00:03:56.020 --> 00:03:58.540
 No need 2 but need 1 

00:03:58.540 --> 00:04:02.650
 So 64 + 4 + 1 equals 69 

00:04:02.650 --> 00:04:05.140
 Means we need 1 

00:04:05.140 --> 00:04:07.910
 We will... 

00:04:07.910 --> 00:04:09.910
 Replace the middle element with X 

00:04:09.910 --> 00:04:12.710
 No need 2 does need 4 

00:04:12.710 --> 00:04:14.710
 No need 8 

00:04:14.710 --> 00:04:16.709
 No need for 16 

00:04:16.709 --> 00:04:18.709
 No need for 32 

00:04:18.709 --> 00:04:20.709
 Need 64 

00:04:20.709 --> 00:04:23.390
 No need for 128 

00:04:23.390 --> 00:04:27.870
 Can start as before the previous input 

00:04:27.870 --> 00:04:32.410
 That is... X···· 

00:04:32.410 --> 00:04:36.110
 When the beginning is a 

00:04:36.110 --> 00:04:38.230
 On the left is a 

00:04:38.230 --> 00:04:39.810
 On the right is a 

00:04:39.810 --> 00:04:43.730
 ··· Replace with X 

00:04:43.730 --> 00:04:46.440
 Or··· Become X 

00:04:46.440 --> 00:04:48.610
 ··X becomes · 

00:04:48.610 --> 00:04:50.510
 Note that we are looking at the following elements 

00:04:50.510 --> 00:04:54.760
 ·X· corresponds to the number 4 is an X 

00:04:54.760 --> 00:04:58.220
 X·· is a 

00:04:58.220 --> 00:05:02.140
 ··· is an X 

00:05:02.140 --> 00:05:06.350
 ··· or X 

00:05:06.350 --> 00:05:08.350
 This is the content of the first line. 

00:05:08.350 --> 00:05:13.350
 Continue and fill in a few lines of content 

00:05:13.350 --> 00:05:15.350
 Look at what happens to pattern 

00:05:15.350 --> 00:05:17.700
 Now to line 6 

00:05:17.700 --> 00:05:22.800
 Found that this line is exactly the same as line 5 

00:05:22.800 --> 00:05:26.640
 Means that line 7 will be exactly the same 

00:05:26.640 --> 00:05:30.850
 Some values ​​make these patterns stable 

00:05:30.850 --> 00:05:34.660
 The results of other values ​​are more confusing 

00:05:34.660 --> 00:05:36.660
 So there are many rules worth studying 

00:05:36.660 --> 00:05:40.270
 Now look at the actual code 

00:05:40.270 --> 00:05:46.820
 Now please pass in a string 

00:05:46.820 --> 00:05:51.350
 a string consisting of · and X 

00:05:51.350 --> 00:05:57.900
 Pattern number is a number between 0 and 255 

00:05:57.900 --> 00:06:05.520
 And based on this, determine which locations are · which are X 

00:06:05.520 --> 00:06:09.280
 I will provide this information here. 

00:06:09.280 --> 00:06:13.680
 That is, the number corresponding to XX· 

00:06:13.680 --> 00:06:15.680
 You will study this pattern 

00:06:15.680 --> 00:06:21.140
 Finally, the number of repetitions is a positive integer. 

00:06:21.140 --> 00:06:23.550
 1 2 3 4 and so on 

00:06:23.550 --> 00:06:27.330
 The output should be generation 

00:06:27.330 --> 00:06:31.010
 Or a string at generation n 

00:06:31.010 --> 00:06:37.340
 For example if the input string is these 

00:06:37.340 --> 00:06:40.510
 Pattern is 69 

00:06:40.510 --> 00:06:42.840
 Generation is 5 

00:06:42.840 --> 00:06:51.622
 You should return ".xxxx" 

