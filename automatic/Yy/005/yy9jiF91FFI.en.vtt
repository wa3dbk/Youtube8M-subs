WEBVTT
Kind: captions
Language: en

00:00:08.510 --> 00:00:11.240 

for<00:00:09.510> 20<00:00:09.780> years<00:00:09.809> storage<00:00:10.500> architects<00:00:11.040> have

00:00:11.240 --> 00:00:11.250 
for 20 years storage architects have

00:00:11.250 --> 00:00:13.400 
for 20 years storage architects have
used<00:00:11.490> replication<00:00:12.389> like<00:00:12.780> mirroring<00:00:13.290> and

00:00:13.400 --> 00:00:13.410 
used replication like mirroring and

00:00:13.410 --> 00:00:17.300 
used replication like mirroring and
erasure<00:00:14.160> codes<00:00:14.639> used<00:00:15.360> in<00:00:15.630> raid<00:00:15.809> 5<00:00:16.080> &amp;<00:00:16.350> 6<00:00:16.590> to

00:00:17.300 --> 00:00:17.310 
erasure codes used in raid 5 &amp; 6 to

00:00:17.310 --> 00:00:19.580 
erasure codes used in raid 5 &amp; 6 to
protect<00:00:17.699> data<00:00:17.970> but<00:00:18.630> recent<00:00:19.020> advances<00:00:19.590> in

00:00:19.580 --> 00:00:19.590 
protect data but recent advances in

00:00:19.590 --> 00:00:22.070 
protect data but recent advances in
erasure<00:00:20.220> code<00:00:20.430> math<00:00:20.640> have<00:00:20.970> given<00:00:21.210> us<00:00:21.330> exciting

00:00:22.070 --> 00:00:22.080 
erasure code math have given us exciting

00:00:22.080 --> 00:00:25.130 
erasure code math have given us exciting
new<00:00:22.439> options<00:00:23.010> I'm<00:00:23.760> looking<00:00:24.060> at<00:00:24.359> how<00:00:24.480> amplitude

00:00:25.130 --> 00:00:25.140 
new options I'm looking at how amplitude

00:00:25.140 --> 00:00:27.620 
new options I'm looking at how amplitude
a<00:00:25.170> uses<00:00:25.710> these<00:00:25.920> advanced<00:00:26.519> codes<00:00:26.789> to<00:00:27.449> offer

00:00:27.620 --> 00:00:27.630 
a uses these advanced codes to offer

00:00:27.630 --> 00:00:30.109 
a uses these advanced codes to offer
exceptional<00:00:28.260> redundancy<00:00:29.130> with<00:00:29.369> low<00:00:29.609> overhead

00:00:30.109 --> 00:00:30.119 
exceptional redundancy with low overhead

00:00:30.119 --> 00:00:33.740 
exceptional redundancy with low overhead
and<00:00:30.330> high<00:00:30.869> performance<00:00:31.730> all<00:00:32.730> erasure<00:00:33.329> codes

00:00:33.740 --> 00:00:33.750 
and high performance all erasure codes

00:00:33.750 --> 00:00:36.950 
and high performance all erasure codes
break<00:00:34.380> data<00:00:35.160> into<00:00:35.670> n<00:00:35.850> fragments<00:00:36.660> then

00:00:36.950 --> 00:00:36.960 
break data into n fragments then

00:00:36.960 --> 00:00:39.290 
break data into n fragments then
transforms<00:00:37.739> these<00:00:37.950> fragments<00:00:38.550> into<00:00:38.700> n<00:00:38.940> plus

00:00:39.290 --> 00:00:39.300 
transforms these fragments into n plus

00:00:39.300 --> 00:00:42.440 
transforms these fragments into n plus
one<00:00:39.600> or<00:00:39.870> more<00:00:40.170> pieces<00:00:40.829> the<00:00:41.520> key<00:00:41.730> benefit<00:00:42.239> only

00:00:42.440 --> 00:00:42.450 
one or more pieces the key benefit only

00:00:42.450 --> 00:00:44.930 
one or more pieces the key benefit only
n<00:00:43.200> fragments<00:00:43.950> are<00:00:44.100> needed<00:00:44.430> to<00:00:44.460> reconstruct

00:00:44.930 --> 00:00:44.940 
n fragments are needed to reconstruct

00:00:44.940 --> 00:00:47.840 
n fragments are needed to reconstruct
the<00:00:45.390> data<00:00:45.420> add<00:00:46.320> more<00:00:46.680> fragments<00:00:47.250> to<00:00:47.399> get<00:00:47.550> any

00:00:47.840 --> 00:00:47.850 
the data add more fragments to get any

00:00:47.850 --> 00:00:51.319 
the data add more fragments to get any
level<00:00:48.270> of<00:00:48.390> redundancy<00:00:49.039> for<00:00:50.039> example<00:00:50.610> in<00:00:50.789> a

00:00:51.319 --> 00:00:51.329 
level of redundancy for example in a

00:00:51.329 --> 00:00:53.869 
level of redundancy for example in a
seven<00:00:51.690> plus<00:00:51.960> one<00:00:52.199> raid<00:00:52.530> five<00:00:52.829> the<00:00:53.430> data<00:00:53.670> is

00:00:53.869 --> 00:00:53.879 
seven plus one raid five the data is

00:00:53.879 --> 00:00:55.939 
seven plus one raid five the data is
broken<00:00:54.270> into<00:00:54.420> eight<00:00:54.629> fragments<00:00:55.289> one<00:00:55.680> of<00:00:55.800> which

00:00:55.939 --> 00:00:55.949 
broken into eight fragments one of which

00:00:55.949 --> 00:00:58.549 
broken into eight fragments one of which
is<00:00:55.980> parity<00:00:56.489> and<00:00:56.760> any<00:00:57.539> seven<00:00:58.170> of<00:00:58.320> the<00:00:58.440> eight

00:00:58.549 --> 00:00:58.559 
is parity and any seven of the eight

00:00:58.559 --> 00:01:02.479 
is parity and any seven of the eight
fragments<00:00:59.250> recreates<00:00:59.969> your<00:01:00.210> data<00:01:01.489> unlike

00:01:02.479 --> 00:01:02.489 
fragments recreates your data unlike

00:01:02.489 --> 00:01:05.329 
fragments recreates your data unlike
raid<00:01:02.850> five<00:01:03.210> or<00:01:03.660> six<00:01:04.049> amp<00:01:04.589> ledee<00:01:04.949> does<00:01:05.100> rate

00:01:05.329 --> 00:01:05.339 
raid five or six amp ledee does rate

00:01:05.339 --> 00:01:07.070 
raid five or six amp ledee does rate
lists<00:01:05.640> or<00:01:05.760> racial<00:01:06.090> coding<00:01:06.450> doesn't<00:01:06.900> keep

00:01:07.070 --> 00:01:07.080 
lists or racial coding doesn't keep

00:01:07.080 --> 00:01:09.770 
lists or racial coding doesn't keep
disks<00:01:07.530> in<00:01:07.680> a<00:01:07.770> raid<00:01:07.979> group<00:01:08.280> data<00:01:09.030> fragments<00:01:09.360> are

00:01:09.770 --> 00:01:09.780 
disks in a raid group data fragments are

00:01:09.780 --> 00:01:11.840 
disks in a raid group data fragments are
distributed<00:01:10.380> intelligently<00:01:11.220> across<00:01:11.640> the

00:01:11.840 --> 00:01:11.850 
distributed intelligently across the

00:01:11.850 --> 00:01:15.230 
distributed intelligently across the
infrastructure<00:01:12.450> here's<00:01:13.380> Paul<00:01:13.740> speciali<00:01:14.340> VP<00:01:15.210> a

00:01:15.230 --> 00:01:15.240 
infrastructure here's Paul speciali VP a

00:01:15.240 --> 00:01:17.840 
infrastructure here's Paul speciali VP a
Tampa<00:01:15.750> data<00:01:15.960> to<00:01:16.500> outline<00:01:16.890> the<00:01:17.130> architecture

00:01:17.840 --> 00:01:17.850 
Tampa data to outline the architecture

00:01:17.850 --> 00:01:20.270 
Tampa data to outline the architecture
so<00:01:18.840> how<00:01:18.990> does<00:01:19.049> an<00:01:19.229> object<00:01:19.560> gets<00:01:19.680> stored<00:01:19.950> in

00:01:20.270 --> 00:01:20.280 
so how does an object gets stored in

00:01:20.280 --> 00:01:22.580 
so how does an object gets stored in
amplitur<00:01:20.850> so<00:01:21.150> an<00:01:21.390> application<00:01:21.990> is<00:01:22.200> going<00:01:22.439> to

00:01:22.580 --> 00:01:22.590 
amplitur so an application is going to

00:01:22.590 --> 00:01:25.429 
amplitur so an application is going to
send<00:01:23.159> us<00:01:23.280> some<00:01:23.460> kind<00:01:23.610> of<00:01:23.960> object<00:01:24.960> that<00:01:25.320> they

00:01:25.429 --> 00:01:25.439 
send us some kind of object that they

00:01:25.439 --> 00:01:26.719 
send us some kind of object that they
want<00:01:25.590> to<00:01:25.650> store<00:01:25.799> an<00:01:25.920> object<00:01:26.220> is<00:01:26.310> a<00:01:26.340> file

00:01:26.719 --> 00:01:26.729 
want to store an object is a file

00:01:26.729 --> 00:01:28.700 
want to store an object is a file
typically<00:01:27.450> it<00:01:27.540> can<00:01:27.689> be<00:01:27.780> a<00:01:27.810> media<00:01:28.140> file<00:01:28.409> it<00:01:28.590> can

00:01:28.700 --> 00:01:28.710 
typically it can be a media file it can

00:01:28.710 --> 00:01:30.859 
typically it can be a media file it can
be<00:01:28.799> a<00:01:28.829> document<00:01:29.340> it's<00:01:29.579> sent<00:01:30.210> to<00:01:30.360> a<00:01:30.390> controller

00:01:30.859 --> 00:01:30.869 
be a document it's sent to a controller

00:01:30.869 --> 00:01:32.630 
be a document it's sent to a controller
the<00:01:31.290> controller<00:01:31.320> receives<00:01:32.040> it<00:01:32.220> over<00:01:32.400> one<00:01:32.549> of

00:01:32.630 --> 00:01:32.640 
the controller receives it over one of

00:01:32.640 --> 00:01:33.980 
the controller receives it over one of
the<00:01:32.729> interfaces<00:01:33.240> it<00:01:33.360> can<00:01:33.479> be<00:01:33.600> a<00:01:33.630> rest

00:01:33.980 --> 00:01:33.990 
the interfaces it can be a rest

00:01:33.990 --> 00:01:37.550 
the interfaces it can be a rest
interface<00:01:34.259> or<00:01:34.770> an<00:01:35.040> API<00:01:35.759> language<00:01:36.479> api<00:01:36.750> call<00:01:37.110> it

00:01:37.550 --> 00:01:37.560 
interface or an API language api call it

00:01:37.560 --> 00:01:39.590 
interface or an API language api call it
ends<00:01:38.159> up<00:01:38.250> on<00:01:38.340> the<00:01:38.460> controller<00:01:38.880> which<00:01:39.180> runs<00:01:39.450> the

00:01:39.590 --> 00:01:39.600 
ends up on the controller which runs the

00:01:39.600 --> 00:01:41.539 
ends up on the controller which runs the
bit<00:01:40.140> spread<00:01:40.320> encoder<00:01:40.680> the<00:01:41.130> bits<00:01:41.310> better

00:01:41.539 --> 00:01:41.549 
bit spread encoder the bits better

00:01:41.549 --> 00:01:43.850 
bit spread encoder the bits better
encoder<00:01:41.820> takes<00:01:42.180> the<00:01:42.390> object<00:01:42.840> and<00:01:43.020> first

00:01:43.850 --> 00:01:43.860 
encoder takes the object and first

00:01:43.860 --> 00:01:46.850 
encoder takes the object and first
segments<00:01:44.549> it<00:01:44.670> into<00:01:45.149> sub<00:01:45.630> chunks<00:01:46.020> the<00:01:46.530> encoder

00:01:46.850 --> 00:01:46.860 
segments it into sub chunks the encoder

00:01:46.860 --> 00:01:48.710 
segments it into sub chunks the encoder
takes<00:01:47.159> that<00:01:47.340> and<00:01:47.520> transforms<00:01:48.119> every<00:01:48.479> one<00:01:48.630> of

00:01:48.710 --> 00:01:48.720 
takes that and transforms every one of

00:01:48.720 --> 00:01:51.200 
takes that and transforms every one of
those<00:01:48.810> objects<00:01:49.290> into<00:01:49.799> a<00:01:50.130> representation<00:01:50.820> of

00:01:51.200 --> 00:01:51.210 
those objects into a representation of

00:01:51.210 --> 00:01:53.810 
those objects into a representation of
the<00:01:51.329> object<00:01:51.720> so<00:01:51.960> it's<00:01:52.079> some<00:01:52.200> calculation<00:01:52.920> ie

00:01:53.810 --> 00:01:53.820 
the object so it's some calculation ie

00:01:53.820 --> 00:01:56.060 
the object so it's some calculation ie
the<00:01:54.180> equation<00:01:54.630> that<00:01:54.750> we<00:01:54.869> talked<00:01:55.079> about<00:01:55.229> so

00:01:56.060 --> 00:01:56.070 
the equation that we talked about so

00:01:56.070 --> 00:01:57.440 
the equation that we talked about so
what's<00:01:56.250> the<00:01:56.369> output<00:01:56.520> of<00:01:56.729> the<00:01:56.820> encoder<00:01:57.210> the

00:01:57.440 --> 00:01:57.450 
what's the output of the encoder the

00:01:57.450 --> 00:01:59.450 
what's the output of the encoder the
output<00:01:57.810> is<00:01:57.840> thousands<00:01:58.680> of<00:01:58.799> equations<00:01:59.280> that

00:01:59.450 --> 00:01:59.460 
output is thousands of equations that

00:01:59.460 --> 00:02:01.249 
output is thousands of equations that
represent<00:01:59.640> the<00:02:00.060> original<00:02:00.540> source<00:02:00.780> data<00:02:01.079> that

00:02:01.249 --> 00:02:01.259 
represent the original source data that

00:02:01.259 --> 00:02:03.380 
represent the original source data that
you<00:02:01.350> sent<00:02:01.590> me<00:02:01.710> from<00:02:01.979> the<00:02:02.159> application<00:02:02.729> the

00:02:03.380 --> 00:02:03.390 
you sent me from the application the

00:02:03.390 --> 00:02:06.109 
you sent me from the application the
encoding<00:02:03.930> process<00:02:04.140> is<00:02:04.680> key<00:02:04.950> let's<00:02:05.729> see<00:02:05.969> how

00:02:06.109 --> 00:02:06.119 
encoding process is key let's see how

00:02:06.119 --> 00:02:07.639 
encoding process is key let's see how
this<00:02:06.270> works<00:02:06.540> with<00:02:06.810> a<00:02:06.869> much<00:02:07.170> simplified

00:02:07.639 --> 00:02:07.649 
this works with a much simplified

00:02:07.649 --> 00:02:11.690 
this works with a much simplified
example<00:02:08.209> will<00:02:09.209> store<00:02:09.569> the<00:02:09.780> number<00:02:09.979> 75<00:02:10.979> we'll

00:02:11.690 --> 00:02:11.700 
example will store the number 75 we'll

00:02:11.700 --> 00:02:13.440 
example will store the number 75 we'll
split<00:02:11.970> it<00:02:12.060> into<00:02:12.330> fragments

00:02:13.440 --> 00:02:13.450 
split it into fragments

00:02:13.450 --> 00:02:15.720 
split it into fragments
and<00:02:13.720> five<00:02:14.140> and<00:02:14.440> send<00:02:15.010> those<00:02:15.190> two<00:02:15.400> amplitudes

00:02:15.720 --> 00:02:15.730 
and five and send those two amplitudes

00:02:15.730 --> 00:02:18.930 
and five and send those two amplitudes
bit<00:02:16.390> spread<00:02:16.720> encoder<00:02:17.319> the<00:02:18.069> encoder<00:02:18.400> generates

00:02:18.930 --> 00:02:18.940 
bit spread encoder the encoder generates

00:02:18.940 --> 00:02:20.910 
bit spread encoder the encoder generates
as<00:02:19.150> many<00:02:19.360> equations<00:02:19.840> is<00:02:20.230> needed<00:02:20.620> for<00:02:20.830> the

00:02:20.910 --> 00:02:20.920 
as many equations is needed for the

00:02:20.920 --> 00:02:23.790 
as many equations is needed for the
desired<00:02:21.370> redundancy<00:02:22.120> here<00:02:22.840> we<00:02:23.200> can<00:02:23.379> lose<00:02:23.530> any

00:02:23.790 --> 00:02:23.800 
desired redundancy here we can lose any

00:02:23.800 --> 00:02:25.559 
desired redundancy here we can lose any
one<00:02:24.010> of<00:02:24.040> the<00:02:24.280> three<00:02:24.430> fragments<00:02:24.790> and<00:02:25.209> still

00:02:25.559 --> 00:02:25.569 
one of the three fragments and still

00:02:25.569 --> 00:02:28.979 
one of the three fragments and still
reconstruct<00:02:26.440> the<00:02:26.590> data<00:02:27.300> replication<00:02:28.300> is

00:02:28.979 --> 00:02:28.989 
reconstruct the data replication is

00:02:28.989 --> 00:02:31.500 
reconstruct the data replication is
storage<00:02:29.500> intensive<00:02:30.190> parity<00:02:30.940> raid<00:02:31.150> drive

00:02:31.500 --> 00:02:31.510 
storage intensive parity raid drive

00:02:31.510 --> 00:02:34.620 
storage intensive parity raid drive
rebuilds<00:02:32.290> take<00:02:32.560> days<00:02:32.860> neither<00:02:33.849> is<00:02:34.000> suitable

00:02:34.620 --> 00:02:34.630 
rebuilds take days neither is suitable

00:02:34.630 --> 00:02:36.449 
rebuilds take days neither is suitable
for<00:02:34.690> the<00:02:34.900> long-term<00:02:35.230> storage<00:02:35.830> of<00:02:36.160> large

00:02:36.449 --> 00:02:36.459 
for the long-term storage of large

00:02:36.459 --> 00:02:39.870 
for the long-term storage of large
amounts<00:02:37.000> of<00:02:37.120> active<00:02:37.510> files<00:02:38.340> with<00:02:39.340> ample<00:02:39.640> edita

00:02:39.870 --> 00:02:39.880 
amounts of active files with ample edita

00:02:39.880 --> 00:02:42.780 
amounts of active files with ample edita
4x<00:02:40.480> redundancy<00:02:41.170> adds<00:02:41.410> only<00:02:41.799> fifty<00:02:42.190> to<00:02:42.340> seventy

00:02:42.780 --> 00:02:42.790 
4x redundancy adds only fifty to seventy

00:02:42.790 --> 00:02:45.270 
4x redundancy adds only fifty to seventy
percent<00:02:42.970> to<00:02:43.420> the<00:02:43.540> data<00:02:43.750> volume<00:02:44.230> each<00:02:44.890> fragment

00:02:45.270 --> 00:02:45.280 
percent to the data volume each fragment

00:02:45.280 --> 00:02:49.320 
percent to the data volume each fragment
is<00:02:45.610> also<00:02:46.000> checksum<00:02:46.540> for<00:02:46.599> safety<00:02:48.120> rate<00:02:49.120> less

00:02:49.320 --> 00:02:49.330 
is also checksum for safety rate less

00:02:49.330 --> 00:02:51.630 
is also checksum for safety rate less
erasure<00:02:49.780> codes<00:02:50.049> are<00:02:50.349> our<00:02:50.470> storage<00:02:50.860> frugal<00:02:51.430> but

00:02:51.630 --> 00:02:51.640 
erasure codes are our storage frugal but

00:02:51.640 --> 00:02:54.479 
erasure codes are our storage frugal but
computationally<00:02:52.000> expensive<00:02:52.690> a<00:02:53.470> problem<00:02:54.280> amp

00:02:54.479 --> 00:02:54.489 
computationally expensive a problem amp

00:02:54.489 --> 00:02:57.569 
computationally expensive a problem amp
litter<00:02:54.849> and<00:02:55.120> Moore's<00:02:55.720> law<00:02:56.049> have<00:02:56.380> solved<00:02:57.010> each

00:02:57.569 --> 00:02:57.579 
litter and Moore's law have solved each

00:02:57.579 --> 00:03:00.059 
litter and Moore's law have solved each
amplitude<00:02:58.360> a<00:02:58.390> control<00:02:58.900> node<00:02:59.200> can<00:02:59.470> encode<00:02:59.829> at

00:03:00.059 --> 00:03:00.069 
amplitude a control node can encode at

00:03:00.069 --> 00:03:01.830 
amplitude a control node can encode at
the<00:03:00.190> rate<00:03:00.340> of<00:03:00.370> seven<00:03:00.910> hundred<00:03:01.239> and<00:03:01.360> fifty

00:03:01.830 --> 00:03:01.840 
the rate of seven hundred and fifty

00:03:01.840 --> 00:03:03.960 
the rate of seven hundred and fifty
megabytes<00:03:02.079> per<00:03:02.680> second<00:03:03.130> than<00:03:03.610> the<00:03:03.790> more

00:03:03.960 --> 00:03:03.970 
megabytes per second than the more

00:03:03.970 --> 00:03:07.890 
megabytes per second than the more
controllers<00:03:04.390> the<00:03:04.750> more<00:03:05.260> bandwidth<00:03:06.900> what

00:03:07.890 --> 00:03:07.900 
controllers the more bandwidth what

00:03:07.900 --> 00:03:10.289 
controllers the more bandwidth what
happens<00:03:08.290> when<00:03:08.470> a<00:03:08.530> storage<00:03:08.950> element<00:03:09.459> disk<00:03:09.880> node

00:03:10.289 --> 00:03:10.299 
happens when a storage element disk node

00:03:10.299 --> 00:03:13.620 
happens when a storage element disk node
or<00:03:10.510> location<00:03:11.200> needs<00:03:11.980> to<00:03:12.190> be<00:03:12.310> rebuilt<00:03:12.700> in<00:03:13.000> a

00:03:13.620 --> 00:03:13.630 
or location needs to be rebuilt in a

00:03:13.630 --> 00:03:15.509 
or location needs to be rebuilt in a
raid<00:03:13.840> system<00:03:14.170> a<00:03:14.470> failed<00:03:14.709> disk<00:03:14.980> has<00:03:15.220> to<00:03:15.400> be

00:03:15.509 --> 00:03:15.519 
raid system a failed disk has to be

00:03:15.519 --> 00:03:18.840 
raid system a failed disk has to be
rebuilt<00:03:15.910> exactly<00:03:16.720> as<00:03:16.900> it<00:03:17.079> was<00:03:17.280> not<00:03:18.280> so<00:03:18.549> with

00:03:18.840 --> 00:03:18.850 
rebuilt exactly as it was not so with

00:03:18.850 --> 00:03:21.420 
rebuilt exactly as it was not so with
rate<00:03:19.090> less<00:03:19.299> erasure<00:03:19.600> codes<00:03:20.019> only<00:03:20.859> fragments

00:03:21.420 --> 00:03:21.430 
rate less erasure codes only fragments

00:03:21.430 --> 00:03:23.610 
rate less erasure codes only fragments
needed<00:03:21.700> to<00:03:21.790> restore<00:03:22.209> desired<00:03:22.660> redundancy<00:03:23.410> are

00:03:23.610 --> 00:03:23.620 
needed to restore desired redundancy are

00:03:23.620 --> 00:03:25.740 
needed to restore desired redundancy are
copied<00:03:24.100> to<00:03:24.280> a<00:03:24.310> replacement<00:03:25.060> or<00:03:25.180> hot<00:03:25.420> spare

00:03:25.740 --> 00:03:25.750 
copied to a replacement or hot spare

00:03:25.750 --> 00:03:29.190 
copied to a replacement or hot spare
node<00:03:26.579> emplid<00:03:27.579> aetas<00:03:27.850> secret<00:03:28.299> sauce<00:03:28.569> is<00:03:28.900> there

00:03:29.190 --> 00:03:29.200 
node emplid aetas secret sauce is there

00:03:29.200 --> 00:03:31.129 
node emplid aetas secret sauce is there
bit<00:03:29.440> spread<00:03:29.739> rate<00:03:30.100> less<00:03:30.310> erasure<00:03:30.700> coding

00:03:31.129 --> 00:03:31.139 
bit spread rate less erasure coding

00:03:31.139 --> 00:03:34.229 
bit spread rate less erasure coding
implementation<00:03:32.139> a<00:03:32.350> product<00:03:33.100> of<00:03:33.190> over<00:03:33.430> 100<00:03:34.030> man

00:03:34.229 --> 00:03:34.239 
implementation a product of over 100 man

00:03:34.239 --> 00:03:37.559 
implementation a product of over 100 man
years<00:03:34.569> of<00:03:34.780> development<00:03:35.230> used<00:03:35.980> in<00:03:36.250> over<00:03:36.569> 1300

00:03:37.559 --> 00:03:37.569 
years of development used in over 1300

00:03:37.569 --> 00:03:40.410 
years of development used in over 1300
deployed<00:03:37.959> customer<00:03:38.620> systems<00:03:39.040> bit<00:03:39.790> spread<00:03:40.120> is

00:03:40.410 --> 00:03:40.420 
deployed customer systems bit spread is

00:03:40.420 --> 00:03:43.910 
deployed customer systems bit spread is
fast<00:03:40.750> efficient<00:03:41.739> flexible<00:03:42.519> robust<00:03:43.299> and

00:03:43.910 --> 00:03:43.920 
fast efficient flexible robust and

00:03:43.920 --> 00:03:47.610 
fast efficient flexible robust and
predictable<00:03:45.660> rate<00:03:46.660> less<00:03:46.900> erasure<00:03:47.230> codes

00:03:47.610 --> 00:03:47.620 
predictable rate less erasure codes

00:03:47.620 --> 00:03:49.470 
predictable rate less erasure codes
offer<00:03:47.950> data<00:03:48.340> protection<00:03:48.819> with<00:03:49.239> lower

00:03:49.470 --> 00:03:49.480 
offer data protection with lower

00:03:49.480 --> 00:03:52.470 
offer data protection with lower
capacity<00:03:49.720> overhead<00:03:50.790> faster<00:03:51.790> rebuilds<00:03:52.359> and

00:03:52.470 --> 00:03:52.480 
capacity overhead faster rebuilds and

00:03:52.480 --> 00:03:54.420 
capacity overhead faster rebuilds and
more<00:03:52.840> redundancy<00:03:53.319> than<00:03:53.620> traditional<00:03:54.220> raid

00:03:54.420 --> 00:03:54.430 
more redundancy than traditional raid

00:03:54.430 --> 00:03:57.330 
more redundancy than traditional raid
systems<00:03:54.970> add<00:03:55.720> the<00:03:56.049> scalability<00:03:56.829> of<00:03:56.859> object

00:03:57.330 --> 00:03:57.340 
systems add the scalability of object

00:03:57.340 --> 00:03:59.520 
systems add the scalability of object
storage<00:03:57.609> and<00:03:58.000> commodity<00:03:58.720> components<00:03:59.380> and

00:03:59.520 --> 00:03:59.530 
storage and commodity components and

00:03:59.530 --> 00:04:01.890 
storage and commodity components and
it's<00:04:00.099> clear<00:04:00.400> that<00:04:00.459> we<00:04:00.819> are<00:04:00.910> entering<00:04:01.329> a<00:04:01.540> post

00:04:01.890 --> 00:04:01.900 
it's clear that we are entering a post

00:04:01.900 --> 00:04:06.780 
it's clear that we are entering a post
raid<00:04:02.260> era<00:04:03.209> for<00:04:04.209> storage<00:04:04.959> mojo<00:04:05.440> I'm<00:04:05.790> Robin

00:04:06.780 --> 00:04:06.790 
raid era for storage mojo I'm Robin

00:04:06.790 --> 00:04:08.940 
raid era for storage mojo I'm Robin
Harris

