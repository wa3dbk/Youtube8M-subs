WEBVTT
Kind: captions
Language: en

00:00:09.640 --> 00:00:14.050 

lesson<00:00:10.640> one<00:00:10.850> bits<00:00:11.540> and<00:00:11.840> bytes<00:00:12.110> all<00:00:13.060> memory

00:00:14.050 --> 00:00:14.060 
lesson one bits and bytes all memory

00:00:14.060 --> 00:00:15.670 
lesson one bits and bytes all memory
inside<00:00:14.360> of<00:00:14.540> a<00:00:14.600> computer<00:00:15.080> is<00:00:15.110> made<00:00:15.440> up<00:00:15.560> of

00:00:15.670 --> 00:00:15.680 
inside of a computer is made up of

00:00:15.680 --> 00:00:18.250 
inside of a computer is made up of
switches<00:00:16.280> just<00:00:16.520> like<00:00:17.240> a<00:00:17.270> light<00:00:17.540> switch<00:00:17.690> these

00:00:18.250 --> 00:00:18.260 
switches just like a light switch these

00:00:18.260 --> 00:00:20.280 
switches just like a light switch these
switches<00:00:18.680> can<00:00:18.860> be<00:00:18.920> they're<00:00:19.340> on<00:00:19.520> or<00:00:19.790> off

00:00:20.280 --> 00:00:20.290 
switches can be they're on or off

00:00:20.290 --> 00:00:22.840 
switches can be they're on or off
numerically<00:00:21.290> we<00:00:21.590> represent<00:00:22.130> these<00:00:22.279> states<00:00:22.610> by

00:00:22.840 --> 00:00:22.850 
numerically we represent these states by

00:00:22.850 --> 00:00:25.990 
numerically we represent these states by
1<00:00:23.090> or<00:00:23.270> 0<00:00:23.570> respectively<00:00:24.400> since<00:00:25.400> these<00:00:25.550> switches

00:00:25.990 --> 00:00:26.000 
1 or 0 respectively since these switches

00:00:26.000 --> 00:00:27.700 
1 or 0 respectively since these switches
have<00:00:26.210> two<00:00:26.419> states<00:00:26.720> they<00:00:27.230> are<00:00:27.290> said<00:00:27.560> to<00:00:27.590> be

00:00:27.700 --> 00:00:27.710 
have two states they are said to be

00:00:27.710 --> 00:00:31.240 
have two states they are said to be
binary<00:00:28.070> a<00:00:29.169> single<00:00:30.169> memory<00:00:30.439> location<00:00:31.040> in<00:00:31.160> a

00:00:31.240 --> 00:00:31.250 
binary a single memory location in a

00:00:31.250 --> 00:00:33.160 
binary a single memory location in a
typical<00:00:31.700> computer<00:00:32.210> is<00:00:32.329> comprised<00:00:32.780> of<00:00:32.960> eight

00:00:33.160 --> 00:00:33.170 
typical computer is comprised of eight

00:00:33.170 --> 00:00:35.200 
typical computer is comprised of eight
of<00:00:33.320> these<00:00:33.440> switches<00:00:33.980> which<00:00:34.430> represent<00:00:35.030> what

00:00:35.200 --> 00:00:35.210 
of these switches which represent what

00:00:35.210 --> 00:00:37.390 
of these switches which represent what
is<00:00:35.300> called<00:00:35.540> the<00:00:35.660> byte<00:00:35.870> of<00:00:35.990> data<00:00:36.220> with<00:00:37.220> eight

00:00:37.390 --> 00:00:37.400 
is called the byte of data with eight

00:00:37.400 --> 00:00:39.760 
is called the byte of data with eight
switches<00:00:37.940> we<00:00:38.300> have<00:00:38.390> two<00:00:38.600> to<00:00:38.750> the<00:00:38.780> eight<00:00:38.989> equal

00:00:39.760 --> 00:00:39.770 
switches we have two to the eight equal

00:00:39.770 --> 00:00:43.180 
switches we have two to the eight equal
to<00:00:39.890> 256<00:00:40.730> possible<00:00:41.180> States<00:00:41.870> each<00:00:42.800> of<00:00:43.070> these

00:00:43.180 --> 00:00:43.190 
to 256 possible States each of these

00:00:43.190 --> 00:00:45.100 
to 256 possible States each of these
states<00:00:43.520> corresponds<00:00:44.270> to<00:00:44.330> an<00:00:44.480> integer<00:00:44.780> between

00:00:45.100 --> 00:00:45.110 
states corresponds to an integer between

00:00:45.110 --> 00:00:49.330 
states corresponds to an integer between
0<00:00:45.620> and<00:00:45.830> 255<00:00:46.330> inclusive<00:00:48.070> numbers<00:00:49.070> that<00:00:49.250> we

00:00:49.330 --> 00:00:49.340 
0 and 255 inclusive numbers that we

00:00:49.340 --> 00:00:50.770 
0 and 255 inclusive numbers that we
normally<00:00:49.520> use<00:00:49.790> are<00:00:50.150> written<00:00:50.420> in<00:00:50.510> what<00:00:50.660> is

00:00:50.770 --> 00:00:50.780 
normally use are written in what is

00:00:50.780 --> 00:00:53.050 
normally use are written in what is
known<00:00:50.960> as<00:00:51.020> decimal<00:00:51.680> notation<00:00:52.060> each

00:00:53.050 --> 00:00:53.060 
known as decimal notation each

00:00:53.060 --> 00:00:55.060 
known as decimal notation each
successive<00:00:53.630> digit<00:00:54.110> in<00:00:54.200> the<00:00:54.290> decimal<00:00:54.620> format

00:00:55.060 --> 00:00:55.070 
successive digit in the decimal format

00:00:55.070 --> 00:00:56.980 
successive digit in the decimal format
corresponds<00:00:55.820> to<00:00:55.880> the<00:00:56.090> next<00:00:56.330> higher<00:00:56.480> power<00:00:56.780> of

00:00:56.980 --> 00:00:56.990 
corresponds to the next higher power of

00:00:56.990 --> 00:00:59.590 
corresponds to the next higher power of
10<00:00:57.250> the<00:00:58.250> lowest<00:00:58.550> digit<00:00:58.910> is<00:00:59.030> called<00:00:59.270> the<00:00:59.390> ones

00:00:59.590 --> 00:00:59.600 
10 the lowest digit is called the ones

00:00:59.600 --> 00:01:01.780 
10 the lowest digit is called the ones
digit<00:00:59.810> the<00:01:00.590> next<00:01:00.950> is<00:01:01.070> called<00:01:01.220> the<00:01:01.400> tens<00:01:01.640> digit

00:01:01.780 --> 00:01:01.790 
digit the next is called the tens digit

00:01:01.790 --> 00:01:04.810 
digit the next is called the tens digit
the<00:01:02.720> next<00:01:03.050> the<00:01:03.170> hundreds<00:01:03.560> digit<00:01:03.830> and<00:01:04.250> so<00:01:04.640> on

00:01:04.810 --> 00:01:04.820 
the next the hundreds digit and so on

00:01:04.820 --> 00:01:07.450 
the next the hundreds digit and so on
each<00:01:05.720> of<00:01:05.990> these<00:01:06.080> corresponds<00:01:06.710> to<00:01:06.830> a<00:01:06.950> multiple

00:01:07.450 --> 00:01:07.460 
each of these corresponds to a multiple

00:01:07.460 --> 00:01:11.350 
each of these corresponds to a multiple
of<00:01:07.610> a<00:01:07.700> power<00:01:07.909> of<00:01:08.119> 10<00:01:08.390> so<00:01:09.380> 385<00:01:10.369> for<00:01:10.700> example<00:01:11.150> can

00:01:11.350 --> 00:01:11.360 
of a power of 10 so 385 for example can

00:01:11.360 --> 00:01:13.300 
of a power of 10 so 385 for example can
be<00:01:11.390> thought<00:01:11.659> of<00:01:11.720> as<00:01:11.869> 3<00:01:12.170> times<00:01:12.470> 10<00:01:12.740> to<00:01:12.950> the<00:01:13.070> 2

00:01:13.300 --> 00:01:13.310 
be thought of as 3 times 10 to the 2

00:01:13.310 --> 00:01:17.349 
be thought of as 3 times 10 to the 2
plus<00:01:14.179> 8<00:01:14.479> times<00:01:14.810> 10<00:01:15.049> to<00:01:15.229> the<00:01:15.259> 1<00:01:15.460> plus<00:01:16.460> 5<00:01:16.700> times<00:01:17.060> 10

00:01:17.349 --> 00:01:17.359 
plus 8 times 10 to the 1 plus 5 times 10

00:01:17.359 --> 00:01:21.429 
plus 8 times 10 to the 1 plus 5 times 10
to<00:01:17.539> the<00:01:17.570> 0<00:01:19.390> similarly<00:01:20.390> the<00:01:20.749> switches<00:01:21.200> in<00:01:21.229> a

00:01:21.429 --> 00:01:21.439 
to the 0 similarly the switches in a

00:01:21.439 --> 00:01:23.469 
to the 0 similarly the switches in a
byte<00:01:21.649> represent<00:01:22.280> a<00:01:22.369> binary<00:01:22.609> number<00:01:23.179> where<00:01:23.359> the

00:01:23.469 --> 00:01:23.479 
byte represent a binary number where the

00:01:23.479 --> 00:01:26.319 
byte represent a binary number where the
digits<00:01:23.869> can<00:01:24.079> only<00:01:24.229> be<00:01:24.469> 0<00:01:24.770> or<00:01:24.950> 1<00:01:25.030> instead<00:01:26.030> of<00:01:26.090> the

00:01:26.319 --> 00:01:26.329 
digits can only be 0 or 1 instead of the

00:01:26.329 --> 00:01:29.050 
digits can only be 0 or 1 instead of the
0<00:01:26.600> through<00:01:26.869> 9<00:01:26.899> that<00:01:27.289> we<00:01:27.380> have<00:01:27.560> in<00:01:27.710> decimal<00:01:28.189> each

00:01:29.050 --> 00:01:29.060 
0 through 9 that we have in decimal each

00:01:29.060 --> 00:01:31.419 
0 through 9 that we have in decimal each
digit<00:01:29.600> in<00:01:29.719> a<00:01:29.810> binary<00:01:30.189> representation<00:01:31.189> is

00:01:31.419 --> 00:01:31.429 
digit in a binary representation is

00:01:31.429 --> 00:01:33.639 
digit in a binary representation is
called<00:01:31.520> a<00:01:31.789> bit<00:01:31.999> which<00:01:32.630> is<00:01:32.659> short<00:01:33.049> for<00:01:33.109> binary

00:01:33.639 --> 00:01:33.649 
called a bit which is short for binary

00:01:33.649 --> 00:01:36.249 
called a bit which is short for binary
digit<00:01:34.210> since<00:01:35.210> there<00:01:35.390> are<00:01:35.450> only<00:01:35.539> two<00:01:35.780> possible

00:01:36.249 --> 00:01:36.259 
digit since there are only two possible

00:01:36.259 --> 00:01:39.010 
digit since there are only two possible
states<00:01:36.619> digits<00:01:37.579> in<00:01:37.759> binary<00:01:37.999> represent<00:01:38.840> power

00:01:39.010 --> 00:01:39.020 
states digits in binary represent power

00:01:39.020 --> 00:01:41.980 
states digits in binary represent power
of<00:01:39.350> two<00:01:39.560> this<00:01:40.490> byte<00:01:40.850> for<00:01:41.179> example<00:01:41.659> represents

00:01:41.980 --> 00:01:41.990 
of two this byte for example represents

00:01:41.990 --> 00:01:45.069 
of two this byte for example represents
this<00:01:42.619> binary<00:01:42.889> number<00:01:43.490> which<00:01:44.179> is<00:01:44.359> 2<00:01:44.389> to<00:01:44.689> the<00:01:44.749> 4

00:01:45.069 --> 00:01:45.079 
this binary number which is 2 to the 4

00:01:45.079 --> 00:01:48.580 
this binary number which is 2 to the 4
plus<00:01:45.319> 2<00:01:45.770> to<00:01:45.889> the<00:01:45.920> 3<00:01:46.280> plus<00:01:46.939> 2<00:01:47.240> to<00:01:47.329> the<00:01:47.420> 0<00:01:47.810> which

00:01:48.580 --> 00:01:48.590 
plus 2 to the 3 plus 2 to the 0 which

00:01:48.590 --> 00:01:53.390 
plus 2 to the 3 plus 2 to the 0 which
equals<00:01:48.649> 16<00:01:49.490> plus<00:01:49.909> 8<00:01:50.149> plus<00:01:50.359> 1<00:01:50.569> or<00:01:51.259> 25

00:01:53.390 --> 00:01:53.400 
equals 16 plus 8 plus 1 or 25

00:01:53.400 --> 00:01:56.060 
equals 16 plus 8 plus 1 or 25
likewise<00:01:54.240> despite<00:01:55.080> which<00:01:55.320> consists<00:01:55.890> of<00:01:55.920> all

00:01:56.060 --> 00:01:56.070 
likewise despite which consists of all

00:01:56.070 --> 00:01:58.430 
likewise despite which consists of all
one's<00:01:56.400> represents<00:01:57.180> this<00:01:57.390> binary<00:01:57.690> number<00:01:58.230> made

00:01:58.430 --> 00:01:58.440 
one's represents this binary number made

00:01:58.440 --> 00:02:00.620 
one's represents this binary number made
up<00:01:58.590> of<00:01:58.740> eight<00:01:58.890> ones<00:01:59.190> this<00:02:00.060> is<00:02:00.240> the<00:02:00.330> largest

00:02:00.620 --> 00:02:00.630 
up of eight ones this is the largest

00:02:00.630 --> 00:02:02.390 
up of eight ones this is the largest
number<00:02:00.780> that<00:02:01.140> we<00:02:01.230> can<00:02:01.410> represent<00:02:01.590> in<00:02:02.070> a<00:02:02.160> byte

00:02:02.390 --> 00:02:02.400 
number that we can represent in a byte

00:02:02.400 --> 00:02:04.760 
number that we can represent in a byte
and<00:02:02.610> it<00:02:03.270> is<00:02:03.360> equal<00:02:03.720> to<00:02:03.750> the<00:02:04.020> sum<00:02:04.230> of<00:02:04.410> the<00:02:04.530> powers

00:02:04.760 --> 00:02:04.770 
and it is equal to the sum of the powers

00:02:04.770 --> 00:02:08.680 
and it is equal to the sum of the powers
to<00:02:05.280> from<00:02:06.000> seven<00:02:06.420> to<00:02:06.630> zero<00:02:06.660> the<00:02:07.650> total<00:02:08.070> comes<00:02:08.430> to

00:02:08.680 --> 00:02:08.690 
to from seven to zero the total comes to

00:02:08.690 --> 00:02:13.280 
to from seven to zero the total comes to
255<00:02:10.400> to<00:02:11.400> count<00:02:11.640> in<00:02:11.850> binary<00:02:12.060> we<00:02:12.570> begin<00:02:12.870> with<00:02:13.020> one

00:02:13.280 --> 00:02:13.290 
255 to count in binary we begin with one

00:02:13.290 --> 00:02:15.710 
255 to count in binary we begin with one
add<00:02:13.980> one<00:02:14.280> to<00:02:14.490> it<00:02:14.520> and<00:02:14.820> we<00:02:14.940> get<00:02:15.060> two<00:02:15.270> in<00:02:15.390> the<00:02:15.510> ones

00:02:15.710 --> 00:02:15.720 
add one to it and we get two in the ones

00:02:15.720 --> 00:02:18.170 
add one to it and we get two in the ones
place<00:02:15.840> this<00:02:16.740> works<00:02:17.070> just<00:02:17.340> like<00:02:17.460> addition<00:02:17.850> in

00:02:18.170 --> 00:02:18.180 
place this works just like addition in

00:02:18.180 --> 00:02:21.590 
place this works just like addition in
decimal<00:02:18.660> when<00:02:19.020> we<00:02:19.140> get<00:02:19.320> ten<00:02:19.620> in<00:02:20.010> fact<00:02:20.730> one<00:02:21.240> zero

00:02:21.590 --> 00:02:21.600 
decimal when we get ten in fact one zero

00:02:21.600 --> 00:02:24.530 
decimal when we get ten in fact one zero
is<00:02:21.900> 2<00:02:22.260> in<00:02:22.410> binary<00:02:22.710> and<00:02:23.130> looks<00:02:23.640> just<00:02:23.760> like<00:02:24.090> 10<00:02:24.360> in

00:02:24.530 --> 00:02:24.540 
is 2 in binary and looks just like 10 in

00:02:24.540 --> 00:02:26.960 
is 2 in binary and looks just like 10 in
decimal<00:02:24.770> with<00:02:25.770> two<00:02:25.950> in<00:02:26.070> the<00:02:26.160> ones<00:02:26.310> place

00:02:26.960 --> 00:02:26.970 
decimal with two in the ones place

00:02:26.970 --> 00:02:29.720 
decimal with two in the ones place
we<00:02:27.360> carry<00:02:27.630> do<00:02:27.780> the<00:02:27.900> twos<00:02:28.140> place<00:02:28.170> to<00:02:28.800> get<00:02:28.980> one

00:02:29.720 --> 00:02:29.730 
we carry do the twos place to get one

00:02:29.730 --> 00:02:33.370 
we carry do the twos place to get one
zero<00:02:30.500> adding<00:02:31.500> one<00:02:31.710> to<00:02:31.920> this<00:02:32.100> we<00:02:32.610> get<00:02:32.790> one<00:02:33.000> one

00:02:33.370 --> 00:02:33.380 
zero adding one to this we get one one

00:02:33.380 --> 00:02:35.990 
zero adding one to this we get one one
adding<00:02:34.380> one<00:02:34.530> again<00:02:34.860> we<00:02:35.160> carry<00:02:35.460> do<00:02:35.610> the<00:02:35.760> twos

00:02:35.990 --> 00:02:36.000 
adding one again we carry do the twos

00:02:36.000 --> 00:02:39.020 
adding one again we carry do the twos
place<00:02:36.110> now<00:02:37.110> we<00:02:37.170> have<00:02:37.440> two<00:02:37.740> or<00:02:38.070> one<00:02:38.400> zero<00:02:38.760> in<00:02:38.940> the

00:02:39.020 --> 00:02:39.030 
place now we have two or one zero in the

00:02:39.030 --> 00:02:41.570 
place now we have two or one zero in the
twos<00:02:39.270> place<00:02:39.410> so<00:02:40.410> this<00:02:40.590> carries<00:02:40.920> to<00:02:41.100> the<00:02:41.130> forest

00:02:41.570 --> 00:02:41.580 
twos place so this carries to the forest

00:02:41.580 --> 00:02:45.010 
twos place so this carries to the forest
place<00:02:41.820> to<00:02:42.420> give<00:02:42.570> us<00:02:42.690> one<00:02:42.960> zero<00:02:43.290> zero<00:02:43.350> or<00:02:43.890> four

00:02:45.010 --> 00:02:45.020 
place to give us one zero zero or four

00:02:45.020 --> 00:02:47.240 
place to give us one zero zero or four
that<00:02:46.020> should<00:02:46.260> give<00:02:46.410> some<00:02:46.620> idea<00:02:46.920> how<00:02:47.100> to<00:02:47.130> work

00:02:47.240 --> 00:02:47.250 
that should give some idea how to work

00:02:47.250 --> 00:02:49.580 
that should give some idea how to work
in<00:02:47.580> binary<00:02:47.820> in<00:02:48.300> general<00:02:48.900> we<00:02:49.110> can<00:02:49.260> add<00:02:49.410> two

00:02:49.580 --> 00:02:49.590 
in binary in general we can add two

00:02:49.590 --> 00:02:52.820 
in binary in general we can add two
binary<00:02:49.830> numbers<00:02:50.040> like<00:02:50.610> this<00:02:50.850> one<00:02:51.570> 0<00:02:51.930> 1<00:02:52.290> 1<00:02:52.500> and<00:02:52.740> 1

00:02:52.820 --> 00:02:52.830 
binary numbers like this one 0 1 1 and 1

00:02:52.830 --> 00:02:57.320 
binary numbers like this one 0 1 1 and 1
0<00:02:53.730> 1<00:02:54.180> 1<00:02:54.420> 0<00:02:54.650> these<00:02:55.650> numbers<00:02:56.040> represent<00:02:56.190> 8<00:02:56.700> plus<00:02:57.120> 2

00:02:57.320 --> 00:02:57.330 
0 1 1 0 these numbers represent 8 plus 2

00:02:57.330 --> 00:03:01.190 
0 1 1 0 these numbers represent 8 plus 2
plus<00:02:57.690> 1<00:02:57.959> equal<00:02:58.440> to<00:02:58.560> 11<00:02:58.980> and<00:02:59.160> 16<00:02:59.970> plus<00:03:00.330> 4<00:03:00.630> plus<00:03:00.900> 2

00:03:01.190 --> 00:03:01.200 
plus 1 equal to 11 and 16 plus 4 plus 2

00:03:01.200 --> 00:03:04.729 
plus 1 equal to 11 and 16 plus 4 plus 2
equal<00:03:01.590> to<00:03:01.620> 22<00:03:02.160> respectively<00:03:03.080> notice<00:03:04.080> that<00:03:04.260> 22

00:03:04.729 --> 00:03:04.739 
equal to 22 respectively notice that 22

00:03:04.739 --> 00:03:06.790 
equal to 22 respectively notice that 22
is<00:03:04.770> 2<00:03:04.920> times<00:03:05.400> 11<00:03:05.580> and<00:03:06.030> it's<00:03:06.480> binary

00:03:06.790 --> 00:03:06.800 
is 2 times 11 and it's binary

00:03:06.800 --> 00:03:09.530 
is 2 times 11 and it's binary
representation<00:03:07.800> is<00:03:07.920> exactly<00:03:08.370> the<00:03:08.610> same<00:03:08.850> but

00:03:09.530 --> 00:03:09.540 
representation is exactly the same but

00:03:09.540 --> 00:03:12.290 
representation is exactly the same but
shifted<00:03:09.959> left<00:03:10.140> by<00:03:10.350> one<00:03:10.560> digit<00:03:11.150> multiplying<00:03:12.150> by

00:03:12.290 --> 00:03:12.300 
shifted left by one digit multiplying by

00:03:12.300 --> 00:03:14.600 
shifted left by one digit multiplying by
2<00:03:12.360> in<00:03:12.600> binary<00:03:12.840> is<00:03:13.200> similar<00:03:13.590> to<00:03:13.920> multiplying<00:03:14.310> by

00:03:14.600 --> 00:03:14.610 
2 in binary is similar to multiplying by

00:03:14.610 --> 00:03:17.120 
2 in binary is similar to multiplying by
10<00:03:14.880> in<00:03:15.060> decimal<00:03:15.320> now<00:03:16.320> if<00:03:16.470> we<00:03:16.590> add<00:03:16.739> these<00:03:16.920> two

00:03:17.120 --> 00:03:17.130 
10 in decimal now if we add these two

00:03:17.130 --> 00:03:21.410 
10 in decimal now if we add these two
numbers<00:03:17.520> we<00:03:17.880> get<00:03:18.030> 1<00:03:18.239> 0<00:03:18.510> 0<00:03:19.200> 0<00:03:19.620> 0<00:03:20.040> 1<00:03:20.430> which<00:03:21.060> equals

00:03:21.410 --> 00:03:21.420 
numbers we get 1 0 0 0 0 1 which equals

00:03:21.420 --> 00:03:25.040 
numbers we get 1 0 0 0 0 1 which equals
33<00:03:22.670> since<00:03:23.670> it<00:03:23.820> is<00:03:23.910> long<00:03:24.120> and<00:03:24.300> cumbersome<00:03:24.720> to

00:03:25.040 --> 00:03:25.050 
33 since it is long and cumbersome to

00:03:25.050 --> 00:03:27.229 
33 since it is long and cumbersome to
write<00:03:25.170> 8<00:03:25.410> digits<00:03:25.890> for<00:03:26.100> a<00:03:26.130> byte<00:03:26.400> computer

00:03:27.229 --> 00:03:27.239 
write 8 digits for a byte computer

00:03:27.239 --> 00:03:29.090 
write 8 digits for a byte computer
scientists<00:03:27.780> prefer<00:03:28.140> more<00:03:28.410> economical

00:03:29.090 --> 00:03:29.100 
scientists prefer more economical

00:03:29.100 --> 00:03:31.940 
scientists prefer more economical
representation<00:03:30.110> breaking<00:03:31.110> a<00:03:31.200> bite<00:03:31.410> into<00:03:31.620> two

00:03:31.940 --> 00:03:31.950 
representation breaking a bite into two

00:03:31.950 --> 00:03:34.760 
representation breaking a bite into two
we<00:03:32.580> have<00:03:32.730> two<00:03:32.940> 4-bit<00:03:33.540> sets<00:03:33.900> which<00:03:34.590> are

00:03:34.760 --> 00:03:34.770 
we have two 4-bit sets which are

00:03:34.770 --> 00:03:37.699 
we have two 4-bit sets which are
referred<00:03:35.100> to<00:03:35.160> as<00:03:35.489> nibbles<00:03:35.910> a<00:03:36.180> nibble<00:03:37.080> or<00:03:37.290> four

00:03:37.699 --> 00:03:37.709 
referred to as nibbles a nibble or four

00:03:37.709 --> 00:03:40.670 
referred to as nibbles a nibble or four
bits<00:03:37.980> can<00:03:38.310> take<00:03:38.550> 16<00:03:39.150> distinct<00:03:39.750> configurations

00:03:40.670 --> 00:03:40.680 
bits can take 16 distinct configurations

00:03:40.680 --> 00:03:44.300 
bits can take 16 distinct configurations
each<00:03:41.420> of<00:03:42.420> these<00:03:42.540> 16<00:03:43.050> configurations<00:03:43.920> can<00:03:44.130> be

00:03:44.300 --> 00:03:44.310 
each of these 16 configurations can be

00:03:44.310 --> 00:03:46.340 
each of these 16 configurations can be
represented<00:03:45.000> by<00:03:45.090> a<00:03:45.120> single<00:03:45.420> digit<00:03:45.900> character

00:03:46.340 --> 00:03:46.350 
represented by a single digit character

00:03:46.350 --> 00:03:48.770 
represented by a single digit character
like<00:03:46.680> this<00:03:47.000> since<00:03:48.000> there<00:03:48.269> are<00:03:48.360> 16

00:03:48.770 --> 00:03:48.780 
like this since there are 16

00:03:48.780 --> 00:03:50.800 
like this since there are 16
possibilities<00:03:49.320> for<00:03:49.800> each<00:03:49.860> digit<00:03:50.160> this

00:03:50.800 --> 00:03:50.810 
possibilities for each digit this

00:03:50.810 --> 00:03:53.560 
possibilities for each digit this
representation<00:03:51.810> is<00:03:51.959> called<00:03:52.100> hexadecimal

00:03:53.560 --> 00:03:53.570 
representation is called hexadecimal

00:03:53.570 --> 00:03:56.330 
representation is called hexadecimal
accidental<00:03:54.570> digit<00:03:54.930> uses<00:03:55.350> decimal<00:03:55.769> digits<00:03:56.190> to

00:03:56.330 --> 00:03:56.340 
accidental digit uses decimal digits to

00:03:56.340 --> 00:03:59.270 
accidental digit uses decimal digits to
represent<00:03:56.370> 0<00:03:57.120> through<00:03:57.420> 9<00:03:57.450> and<00:03:57.959> A<00:03:58.560> through<00:03:58.860> F<00:03:59.010> to

00:03:59.270 --> 00:03:59.280 
represent 0 through 9 and A through F to

00:03:59.280 --> 00:04:01.680 
represent 0 through 9 and A through F to
represent<00:03:59.790> 10<00:04:00.060> through<00:04:00.300> 15

00:04:01.680 --> 00:04:01.690 
represent 10 through 15

00:04:01.690 --> 00:04:04.750 
represent 10 through 15
with<00:04:02.690> hexadecimal<00:04:03.560> we<00:04:03.950> can<00:04:04.099> represent<00:04:04.280> each

00:04:04.750 --> 00:04:04.760 
with hexadecimal we can represent each

00:04:04.760 --> 00:04:07.509 
with hexadecimal we can represent each
byte<00:04:05.060> as<00:04:05.269> two<00:04:05.450> digits<00:04:05.900> instead<00:04:06.170> of<00:04:06.530> eight<00:04:06.709> for

00:04:07.509 --> 00:04:07.519 
byte as two digits instead of eight for

00:04:07.519 --> 00:04:13.089 
byte as two digits instead of eight for
example<00:04:07.549> this<00:04:08.420> byte<00:04:08.690> 0<00:04:09.409> 1<00:04:09.709> 0<00:04:10.129> 0<00:04:10.220> 1<00:04:10.909> 1<00:04:10.940> 0<00:04:11.330> 1<00:04:11.980> can<00:04:12.980> be

00:04:13.089 --> 00:04:13.099 
example this byte 0 1 0 0 1 1 0 1 can be

00:04:13.099 --> 00:04:17.379 
example this byte 0 1 0 0 1 1 0 1 can be
written<00:04:13.310> in<00:04:13.519> hexadecimal<00:04:13.909> as<00:04:14.480> 4b<00:04:16.389> hexadecimal

00:04:17.379 --> 00:04:17.389 
written in hexadecimal as 4b hexadecimal

00:04:17.389 --> 00:04:20.560 
written in hexadecimal as 4b hexadecimal
numbers<00:04:17.750> are<00:04:17.959> base<00:04:18.229> 16<00:04:18.859> just<00:04:19.760> like<00:04:19.940> binary<00:04:20.209> and

00:04:20.560 --> 00:04:20.570 
numbers are base 16 just like binary and

00:04:20.570 --> 00:04:22.420 
numbers are base 16 just like binary and
decimal<00:04:20.600> numbers<00:04:21.260> are<00:04:21.440> base<00:04:21.650> 2<00:04:21.979> and<00:04:22.190> 10

00:04:22.420 --> 00:04:22.430 
decimal numbers are base 2 and 10

00:04:22.430 --> 00:04:23.379 
decimal numbers are base 2 and 10
respectively

00:04:23.379 --> 00:04:23.389 
respectively

00:04:23.389 --> 00:04:25.650 
respectively
that<00:04:24.020> is<00:04:24.169> each<00:04:24.650> digit<00:04:25.190> in<00:04:25.310> hexadecimal

00:04:25.650 --> 00:04:25.660 
that is each digit in hexadecimal

00:04:25.660 --> 00:04:29.250 
that is each digit in hexadecimal
represents<00:04:26.660> a<00:04:26.750> multiple<00:04:27.290> of<00:04:27.470> a<00:04:27.650> power<00:04:27.860> of<00:04:28.100> 16

00:04:29.250 --> 00:04:29.260 
represents a multiple of a power of 16

00:04:29.260 --> 00:04:33.100 
represents a multiple of a power of 16
for<00:04:30.260> programming<00:04:30.800> purposes<00:04:31.370> we<00:04:31.729> prepend<00:04:32.270> 0<00:04:32.840> X

00:04:33.100 --> 00:04:33.110 
for programming purposes we prepend 0 X

00:04:33.110 --> 00:04:35.560 
for programming purposes we prepend 0 X
2<00:04:33.710> X<00:04:33.889> ax<00:04:34.039> decimal<00:04:34.460> numbers<00:04:34.820> to<00:04:35.030> signify<00:04:35.510> the

00:04:35.560 --> 00:04:35.570 
2 X ax decimal numbers to signify the

00:04:35.570 --> 00:04:37.090 
2 X ax decimal numbers to signify the
number<00:04:36.020> base<00:04:36.229> 16

00:04:37.090 --> 00:04:37.100 
number base 16

00:04:37.100 --> 00:04:42.270 
number base 16
so<00:04:37.789> that<00:04:37.970> 4b<00:04:38.510> is<00:04:38.720> written<00:04:39.530> as<00:04:39.680> 0<00:04:39.979> X<00:04:40.250> 4<00:04:40.580> B<00:04:41.060> in<00:04:41.300> C++

00:04:42.270 --> 00:04:42.280 
so that 4b is written as 0 X 4 B in C++

00:04:42.280 --> 00:04:45.040 
so that 4b is written as 0 X 4 B in C++
this<00:04:43.280> allows<00:04:43.580> us<00:04:43.610> to<00:04:43.970> distinguish<00:04:44.479> the<00:04:44.750> number

00:04:45.040 --> 00:04:45.050 
this allows us to distinguish the number

00:04:45.050 --> 00:04:48.310 
this allows us to distinguish the number
base<00:04:45.260> so<00:04:46.010> that<00:04:46.039> we<00:04:46.280> know<00:04:46.460> that<00:04:46.669> 1<00:04:46.940> 1<00:04:47.210> equals<00:04:48.050> 10

00:04:48.310 --> 00:04:48.320 
base so that we know that 1 1 equals 10

00:04:48.320 --> 00:04:53.020 
base so that we know that 1 1 equals 10
plus<00:04:48.350> 1<00:04:48.889> and<00:04:49.160> 0<00:04:49.850> X<00:04:50.180> 1<00:04:50.539> 1<00:04:50.889> equals<00:04:51.889> 16<00:04:52.400> plus<00:04:52.760> 1

00:04:53.020 --> 00:04:53.030 
plus 1 and 0 X 1 1 equals 16 plus 1

00:04:53.030 --> 00:04:58.600 
plus 1 and 0 X 1 1 equals 16 plus 1
which<00:04:53.389> is<00:04:53.419> 17<00:04:54.169> this<00:04:55.120> concludes<00:04:56.120> the<00:04:56.389> lesson

